#include "code_generator.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>
#include <stdint.h>
#include <map>
#include <string>
#include <iostream>
#include <locale>
#include <vector>
#include <set>
#include <list>
#include "primex_config.h" // global configuration generated by autoconf

#define BASE_TYPE_ID 1000
extern "C"
{
    int yyparse(void);
    int yylex(void);
	int lex_setup(const char* file);
	void lex_teardown();

    int yywrap();
}

#define FATAL(...) {fprintf(stderr,"[%s:%i]",__FILE__,__LINE__);fprintf(stderr,__VA_ARGS__);fprintf(stderr,"\n");exit(100);}


std::string fixAttrName(char* name) {
	std::string str;
	str.append(name);
	str[0]=toupper(str[0]);
	int pos = str.find('_');
	while(pos<str.length()){
		if(pos+1<str.length())
			str[pos+1]=toupper(str[pos+1]);
		for(int j=pos+1;j<str.length();j++) {
			str[j-1]=str[j];
		}
		str.erase(str.length()-1,1);
		pos = str.find('_',pos+1);
	}
	return str;
}

/**
 * return true if found, false otherwise.
 *
 * if found, start is set to the first
 * char of the substring and stop to the last
 */
bool find_substr(char* haystack, char* needle, int& start, int& stop) {
	int cur=0, end=strlen(haystack), len = strlen(needle);
	while(cur+len <= end) {
		if(!strncmp(haystack+cur,needle,len)) {
			//found it
			start = cur;
			stop = start+len;
			return true;
		}
		cur++;
	}
	return false;
}

temp_ll_t* root = 0;
temp_ll_t* root_type=0;

config_type_t* getHead() {
	if(root) {
		return root->data;
	}
	return 0;
}

config_type_t* createConfigType() {
	config_type_t* rv = (config_type_t*) malloc(sizeof(config_type_t));
	bzero(rv, sizeof(config_type_t));
	return rv;
}

config_var_t* createConfigVar() {
	config_var_t* rv = (config_var_t*) malloc(sizeof(config_var_t));
	bzero(rv, sizeof(config_var_t));
	return rv;
}
config_child_t* createConfigChild() {
	config_child_t* rv = (config_child_t*) malloc(sizeof(config_child_t));
	bzero(rv, sizeof(config_child_t));
	return rv;
}

config_type_t* addConfigType(char* cls_name, char* cls_tpl, char* extends, char* extends_tpl, char* type_id, char* alias, char* filename) {
	temp_ll_t* ll=(temp_ll_t*)malloc(sizeof(temp_ll_t));
	ll->data=createConfigType();
	if(cls_name)
		ll->data->name = strdup(cls_name);
	if(cls_tpl)
		ll->data->name_tpl = strdup(cls_tpl);
	if(extends)
		ll->data->extends = strdup(extends);
	if(extends_tpl)
		ll->data->extends_tpl = strdup(extends_tpl);

	if(type_id)
		ll->data->type_id = strdup(type_id);
	if(alias)
		ll->data->alias = strdup(alias);
	if(filename)
		ll->data->filename=strdup(filename);
	ll->next=root;
	root=ll;
	return ll->data;
}

config_var_t* addConfigVar(
		config_type_t* parent,
		short is_shared,
		short is_configurable,
		short is_visualized,
		short is_stat,
		char* config_type,
		char* c_type,
		char* name,
		char* default_value,
		char* serialize_fct,
		char* unserialize_fct,
		char* doc_string,
		char* raw_string) {
	if(!parent) {
		FATAL("parent was null in addConfigVar!\n")
	}
	config_var_t* cv = createConfigVar();
	cv->parent=parent;
	if(!parent->first_var) {
		parent->first_var=cv;
		parent->last_var=cv;
		parent->first_var->next=0;
		parent->first_var->prev=0;
	}
	else {
		cv->prev=parent->last_var;
		parent->last_var->next=cv;
		parent->last_var=cv;
	}

	if(config_type)cv->config_type=strdup(config_type);
	if(c_type)cv->c_type=strdup(c_type);
	if(name)cv->name=strdup(name);
	if(default_value)cv->default_value=strdup(default_value);
	if(serialize_fct)cv->serialize_fct=strdup(serialize_fct);
	if(unserialize_fct)cv->unserialize_fct=strdup(unserialize_fct);
	if(doc_string)cv->doc_string=strdup(doc_string);
	if(raw_string)cv->raw_string=strdup(raw_string);
	cv->is_configurable=is_configurable;
	cv->is_shared=is_shared;
	cv->is_visualized=is_visualized;
	cv->is_stat=is_stat;
	return cv;
}

config_child_t* addConfigChild(config_type_t* parent, char* c_type, char* name, char* min, char* max,
		char* is_aliased, char* doc_string) {
	if(!parent) {
		FATAL("parent was null in addConfigChild!\n");
	}
	config_child_t* cv = createConfigChild();
	cv->parent=parent;
	if(!parent->first_child) {
		parent->first_child=cv;
		parent->last_child=cv;
		parent->first_child->next=NULL;
		parent->first_child->prev=NULL;
	}
	else {
		cv->prev=parent->last_child;
		parent->last_child->next=cv;
		parent->last_child=cv;
	}
	if(c_type)cv->c_type=strdup(c_type);
	if(name)cv->name=strdup(name);
	if(doc_string)cv->doc_string=strdup(doc_string);
	if(min)cv->min=strdup(min);
	if(max)cv->max=strdup(max);
	if(doc_string)cv->doc_string=strdup(doc_string);
	cv->is_aliased=false;
	if(is_aliased) {
		if(0!=strcasecmp("false",is_aliased) && 0!=strcmp("0",is_aliased)) {
			cv->is_aliased=true;
		}
	}
	return cv;
}

void figure_out_config_type(config_var_t* t) {
	if(!t->c_type) {
		FATAL("Should never see this!\n");
	}
	if( !strcmp(t->c_type,"unsigned long long") ||
		!strcmp(t->c_type,"unsigned long int") ||
		!strcmp(t->c_type,"unsigned long") ||
		!strcmp(t->c_type,"unsigned int") ||
		!strcmp(t->c_type,"unsigned short") ||
		!strcmp(t->c_type,"signed long long") ||
		!strcmp(t->c_type,"signed long int") ||
		!strcmp(t->c_type,"signed long") ||
		!strcmp(t->c_type,"signed int") ||
		!strcmp(t->c_type,"signed short") ||
		!strcmp(t->c_type,"long long") ||
		!strcmp(t->c_type,"long int") ||
		!strcmp(t->c_type,"long") ||
		!strcmp(t->c_type,"int") ||
		!strcmp(t->c_type,"short")) {
		t->config_type=strdup("INT");
	}
	else if(!strcmp(t->c_type,"unsigned char") ||
		!strcmp(t->c_type,"signed char") ||
		!strcmp(t->c_type,"char") ||
		!strcmp(t->c_type,"SSFNET_STRNIG") ||
		!strcmp(t->c_type,"std::string")) {
		t->config_type=strdup("STRING");
	}
	else if(!strcmp(t->c_type,"float")) {
		t->config_type=strdup("FLOAT");
	}
	else if(!strcmp(t->c_type,"ResourceIdentifier")) {
		t->config_type=strdup("RESOURCE_ID");
	}
	else {
		t->config_type=strdup("OBJECT");
	}

	if(!t->config_type) {
		FATAL("[%s:%i]Should never see this!\n",__FILE__,__LINE__);
	}
}

void write_warning(FILE* fp) {
	fprintf(fp,"/* ------------------------- */\n");
	fprintf(fp,"/* ------------------------- */\n");
	fprintf(fp,"/*         WARNING: */\n");
	fprintf(fp,"/*  THIS FILE IS GENERATED! */\n");
	fprintf(fp,"/*        DO NOT EDIT! */\n");
	fprintf(fp,"/* ------------------------- */\n");
	fprintf(fp,"/* ------------------------- */\n\n");
}



void gen_common_hdr(config_type_t* type, FILE* fp) {
	//XXX this is just place holder code
}

void gen_common_impl(config_type_t* type, FILE* fp) {
	//XXX this is just place holder code
	if(!type->extends || strlen(type->extends)==0) {
		type->extends=strdup("BaseEntity");
	}
	fprintf(fp,"\n\n//class %s : public %s ...\n",type->name,type->extends);

	if(type->alias && strlen(type->alias)>0) {
		fprintf(fp,"SSFNET_REGISTER_ENTITY(%s, %s, %s, %s, %i, %i, %i, %i, \"%s\");\n",
				type->name,
				type->name_tpl,
				type->extends,
				type->extends_tpl,
				type->auto_type_ids[IMPL_ID],
				type->auto_type_ids[ALIAS_ID],
				type->auto_type_ids[REPLICA_ID],
				type->auto_type_ids[ALIAS_REPLICA_ID],
				type->alias);

	}
	else {
		fprintf(fp,"SSFNET_REGISTER_ENTITY(%s, %s, %s, %s, %i, %i, %i, %i);\n",
				type->name,
				type->name_tpl,
				type->extends,
				type->extends_tpl,
				type->auto_type_ids[IMPL_ID],
				type->auto_type_ids[ALIAS_ID],
				type->auto_type_ids[REPLICA_ID],
				type->auto_type_ids[ALIAS_REPLICA_ID]);
	}
	config_child_t* cchild = type->first_child;
	while(cchild) {
		if(!cchild->min)cchild->min=strdup("0");
		if(!cchild->max)cchild->max=strdup("0");
		fprintf(fp,"SSFNET_CONFIG_CHILDREN_DEF(%s, %s, %s, %s, %s, %s, \"xxx\");\n",
				type->name,
				cchild->c_type,
				cchild->name,
				cchild->is_aliased?"true":"false",
				cchild->min,
				cchild->max);
		cchild=cchild->next;
	}
	config_var_t * cvar = type->first_var;
	while(cvar) {
		if(cvar->is_shared && cvar->is_configurable) {
			fprintf(fp, "SSFNET_CONFIG_PROPERTY_DEF(%s, %s, %s, false, \"%s\", \"xxx\")\n",
					type->name,
					cvar->config_type,
					cvar->name,
					cvar->default_value);
		}
		else if(!cvar->is_shared && cvar->is_configurable) {
			fprintf(fp, "SSFNET_CONFIG_STATE_DEF(%s, %s, %s, false, \"%s\", \"xxx\")\n",
					type->name,
					cvar->config_type,
					cvar->name,
					cvar->default_value);
		}
		else if(!cvar->is_shared && !cvar->is_configurable) {
			fprintf(fp, "//skipping %s %s\n",
					cvar->c_type,
					cvar->name);
		}
		else if(cvar->is_shared && !cvar->is_configurable) {
			fprintf(fp, "//skipping %s %s\n",
					cvar->c_type,
					cvar->name);
		}
		else {
			fprintf(fp,"//how did I get here? %s:%i\n",__FILE__,__LINE__);
		}
		cvar=cvar->next;
	}
	fprintf(fp,"SSFNET_PROPMAP_DEF(%s",type->name);
	cvar = type->first_var;
	while(cvar) {
		if(cvar->is_shared && cvar->is_configurable) {
			fprintf(fp, ", &%s",cvar->name);
		}
		cvar=cvar->next;
	}
	fprintf(fp, ")\n");
	fprintf(fp,"SSFNET_STATEMAP_DEF(%s",type->name);
	cvar = type->first_var;
	while(cvar) {
		if(!cvar->is_shared && cvar->is_configurable) {
			fprintf(fp, ", &%s",cvar->name);
		}
		cvar=cvar->next;
	}
	fprintf(fp, ")\n");
}

void assign_ids(config_type_t* c, int& impl_base, int& alias_base, int& replica_base, int& alias_replica_base) {
	c->auto_type_ids[IMPL_ID]=impl_base++;
	c->auto_type_ids[ALIAS_ID]=alias_base++;
	c->auto_type_ids[REPLICA_ID]=replica_base++;
	c->auto_type_ids[ALIAS_REPLICA_ID]=alias_replica_base++;
	config_type_t* cur=c->first_sub_type;
	while(cur) {
		assign_ids(cur, impl_base,alias_base,replica_base,alias_replica_base);
		cur=cur->next;
	}
}
std::vector<config_type_t*> root_types;
std::map<std::string, config_type_t*> types;
std::map<uint32_t, std::pair<char*,char*> > var_ids;
std::map<std::string,uint32_t> var_strings;

bool is_sub_type(config_type_t* super, config_type_t* sub) {
	config_type_t* cur=super->first_sub_type;
	while(cur) {
		if(cur==sub || is_sub_type(cur,sub)) return true;
		cur=cur->next;
	}
	return false;
}

void generateVariableIds() {
	int id=1;
	std::set< std::string > vars;
	temp_ll_t* cur = root;
	while(cur) {
		if(cur->data) {
			config_var_t* cur_var=cur->data->first_var;
			while(cur_var) {
				vars.insert(std::string(cur_var->name));
				cur_var=cur_var->next;
			}
		}
		cur=cur->next;
	}
	for(std::set< std::string >::iterator it=vars.begin();it!=vars.end();it++) {
		var_ids.insert(std::make_pair(id, std::make_pair(strdup((*it).c_str()),(char*)0)));
		var_strings.insert(std::make_pair(std::string(*it),id));
		id++;
	}

	cur = root;
	while(cur) {
		if(cur->data) {
			config_var_t* cur_var=cur->data->first_var;
			while(cur_var) {
				std::map<std::string, uint32_t>::iterator it=var_strings.find(std::string(cur_var->name));
				if(it == var_strings.end()) {
					//its new.
					FATAL("Should never see this!\n");
				}
				else {
					cur_var->var_id=it->second;
					std::map<uint32_t, std::pair<char*,char*> >::iterator it2=var_ids.find(cur_var->var_id);
					if(it2 == var_ids.end()) {
						FATAL("Should never see this!\n");
					}
					else {
						it2->second.second=strdup(cur_var->config_type);
					}
				}
				cur_var=cur_var->next;
			}
		}
		cur=cur->next;
	}
}

void fix_type_heirarchy() {
	{
		//Add BaseEntity structure
		config_type_t* be = addConfigType((char*)"BaseEntity", NULL, NULL, NULL, NULL, NULL, NULL);
		addConfigVar(be, 0, 1, 1, 0, (char*)"INT", (char*)"UID_t", (char*)"uid", (char*)"0", NULL, NULL, (char*)"The index of this node in the post-order traversal from top-most network", NULL);
		addConfigVar(be, 0, 1, 1, 0, (char*)"STRING", (char*)"SSFNET_STRING", (char*)"name", (char*)"<no name>", NULL, NULL, (char*)"The number of nodes which precede this node in the post-order traversal from this node's parent", NULL);
		addConfigVar(be, 1, 1, 0, 0, (char*)"INT", (char*)"UID_t", (char*)"size", (char*)"0", NULL, NULL, (char*)"The number of nodes of which this node is an ancestor", NULL);
		addConfigVar(be, 0, 1, 0, 0, (char*)"INT", (char*)"UID_t", (char*)"offset", (char*)"0", NULL, NULL, (char*)"The number of nodes which precede this node in the post-order traversal from this node's parent", NULL);
	}
	temp_ll_t* cur = root;
	std::map<std::string, config_type_t*>::iterator it;
	std::vector<config_type_t*> root_types;
	while(cur) {
		if(cur->data) {
			types.insert(std::make_pair(std::string(cur->data->name),cur->data));
		}
		cur=cur->next;
	}
	cur = root;
	while(cur) {
		if(cur->data) {
			if(cur->data->extends) {
				//it extends something....
				it = types.find(std::string(cur->data->extends));
				if(it==types.end()) {
					fprintf(stderr,"Unable to find the type \"%s\" which is extended by \"%s\"\n", cur->data->extends, cur->data->name);
				}
				config_type_t* parent = (*it).second;
				if(!parent->first_sub_type) {
					parent->first_sub_type=cur->data;
					parent->last_sub_type=cur->data;
					parent->first_sub_type->next=0;
					parent->first_sub_type->prev=0;
				}
				else {
					cur->data->prev=parent->last_sub_type;
					parent->last_sub_type->next=cur->data;
					parent->last_sub_type=cur->data;
				}
			}
			else {
				if(!root_type) {
					root_type=cur;
				}
				else {
					fprintf(stderr, "FOUND MULTIPLE ROOT TYPES! PREV='%s', CUR='%s' !\n",root_type->data->name,cur->data->name);
				}
				root_types.push_back(cur->data);
			}
		}
		cur=cur->next;
	}
	int impl_base=BASE_TYPE_ID;
	int alias_base=BASE_TYPE_ID+types.size();
	int replica_base=BASE_TYPE_ID+types.size()*2;
	int alias_replica_base=BASE_TYPE_ID+types.size()*3;
	std::vector<config_type_t*>::iterator it1;
	for(it1=root_types.begin();it1!=root_types.end();it1++) {
		assign_ids(*it1,impl_base,alias_base, replica_base,alias_replica_base);
	}
	cur = root;
	while(cur) {
		if(cur->data) {
			config_child_t* kid=cur->data->first_child;
			while(kid) {
				it = types.find(std::string(kid->c_type));
				if(it==types.end()) {
					fprintf(stderr,"Unable to find the type \"%s\" which is defined as type of \"%s\"'s child \"%s\"\n", kid->c_type, cur->data->name, kid->name);
				}
				kid->the_type = (*it).second;
				kid=kid->next;
			}
		}
		cur=cur->next;
	}
#if 0
	//print out type heirarchy
	cur = root;
	while(cur) {
		if(cur->data) {
			printf("%s extends %s\n",
					cur->data->name,
					(cur->data->extends?cur->data->extends:"NULL"));
			config_child_t* kid=cur->data->first_child;
			if(kid)
				printf("\tChildTypes:\n");
			while(kid) {
				it = types.find(std::string(kid->c_type));
				printf("\t\t%s (%s)\n",kid->the_type->name, kid->name);
				kid=kid->next;
			}
			config_type_t* scur = cur->data->first_sub_type;
			if(scur)
				printf("\tSubTypes:\n");
			while(scur) {
				printf("\t\t%s\n",scur->name);
				scur=scur->next;
			}
		}
		cur=cur->next;
	}
#endif

}

void gen_hdr(config_type_t* type, FILE* fp) {
	if(!type->extends || strlen(type->extends)==0) {
		type->extends=strdup("BaseEntity");
	}
	//SSFNET_PROPMAP_DECL
	fprintf(fp,"public:\n");
	fprintf(fp,"\tSSFNET_PROPMAP_DECL(\n");
	config_var_t * cvar = type->first_var;
	while(cvar) {
		if(cvar->is_shared) {
			if(cvar->is_configurable) {
				fprintf(fp, "\t\tSSFNET_CONFIG_PROPERTY_DECL(%s, %s)\n",
						cvar->c_type,
						cvar->name);
			}
			else {
				fprintf(fp, "\t\%s %s;\n",
						cvar->c_type,
						cvar->name);
			}
		}
		cvar=cvar->next;
	}

	config_child_t* cchild = type->first_child;
	while(cchild) {
		fprintf(fp,"\t\tSSFNET_CONFIG_CHILDREN_DECL_SHARED(%s, %s)\n",
				cchild->c_type,
				cchild->name);
		cchild=cchild->next;
	}
	fprintf(fp,"\t)\n");

	//SSFNET_STATEMAP_DECL
	fprintf(fp,"\tSSFNET_STATEMAP_DECL(\n");
	cvar = type->first_var;
	while(cvar) {
		if(!cvar->is_shared) {
			if(cvar->is_configurable) {
				fprintf(fp, "\t\tSSFNET_CONFIG_STATE_DECL(%s, %s)\n",
						cvar->c_type,
						cvar->name);
			}
			else {
				fprintf(fp, "\t\t%s %s;\n",
						cvar->c_type,
						cvar->name);
			}
		}
		cvar=cvar->next;
	}
	cchild = type->first_child;
	while(cchild) {
		fprintf(fp,"\t\tSSFNET_CONFIG_CHILDREN_DECL_UNSHARED(%s,%s,%s)\n",
				type->name,
				cchild->c_type,
				cchild->name);
		cchild=cchild->next;
	}
	fprintf(fp,"\t)\n");

	//kids
	cchild = type->first_child;
	while(cchild) {
		fprintf(fp,"\tSSFNET_CONFIG_CHILDREN_DECL(%s, %s)\n",
				cchild->c_type,
				cchild->name);
		cchild=cchild->next;
	}
	fprintf(fp,"\tSSFNET_ENTITY_SETUP(");
	cchild = type->first_child;
	int first=1;
	while(cchild) {
		if(!first)fprintf(fp,", ");
		first=0;
		fprintf(fp,"&(unshared.%s)", cchild->name);
		cchild=cchild->next;
	}
	fprintf(fp," )\n");

}
// look for /* SSFNET_XLATE_EXTRACTION_POINT class="YYY" */
// and insert the generated code there
uint32_t insert_into_header(config_type_t* type) {
	char looking_for[50+strlen(type->name)];
	int lsize=2048;
	if(lsize<(int)(strlen(type->filename)+100))
		lsize=strlen(type->filename)+100;
 	char line[lsize];
 	FILE* origfile, * newfile;

 	sprintf(line,"%s_temp",type->filename);
	sprintf(looking_for,"/* SSFNET_XLATE_EXTRACTION_POINT class=\"%s\" */\n",type->name);
	origfile = fopen(type->filename, "r");
 	if(origfile==NULL) {
 		FATAL("Error opening '%s'\n", type->filename);
 		return 1;
 	}
 	newfile = fopen(line, "w");
 	if(newfile==NULL) {
 		FATAL("Error opening '%s'\n", line);
 		return 1;
 	}

 	while ( fgets ( line, lsize, origfile) != NULL ) {
 		if(!strcmp(looking_for,line)) {
 			gen_hdr(type,newfile);
 		}
 		else {
 			fputs ( line, newfile);
 		}
 	}
 	fclose ( origfile );
 	fclose ( newfile );
 	if(remove(type->filename)) {
 		fprintf(stderr,"There was an error removing '%s'!", type->filename);
 		return 1;
 	}
 	sprintf(line,"%s_temp",type->filename);
 	if(rename(line,type->filename)) {
 		fprintf(stderr,"There was an error removing '%s'!", line);
 		return 1;
 	}
	return 0;
}


void generateCPPCode(char* target_h_file, char* target_cc_file, char** jprime_varnames, int* jprime_varids, int jprime_var_count) {
	temp_ll_t* cur = root;
	FILE *h, *cc;
	h= fopen(target_h_file, "w");
 	cc = fopen(target_cc_file, "w");

 	if(h==NULL) {
 		FATAL("Error opening '%s'\n", target_h_file);
 	}
 	if(cc==NULL) {
 		FATAL("Error opening '%s'\n", target_cc_file);
 	}
	write_warning(h);
	write_warning(cc);

	fprintf(h,"#ifndef __CONFIGURABLE_TYPES_H__\n");
	fprintf(h,"#define __CONFIGURABLE_TYPES_H__\n");

	if(!strncmp("src/ssfnet/",target_h_file,strlen("src/ssfnet/"))) {
		fprintf(cc, "#include \"%s\"\n",target_h_file+strlen("src/ssfnet/"));
	}
	else {
		fprintf(cc, "#include \"%s\"\n",target_h_file);
	}
	fprintf(cc,"namespace prime {\n");
	fprintf(cc,"namespace ssfnet {\n");

	fprintf(cc, "\n SSFNET_MAP(int,SSFNET_STRING*)* jprime_type_names=NULL;\n");
	fprintf(cc, "void setup_jprime_type_types(){\n");
	fprintf(cc, "\tjprime_type_names=new SSFNET_MAP(int,SSFNET_STRING*)();\n");
	int t1,t2;
	int found=0;
	if(jprime_var_count != 8) {
		FATAL("I expected 8 jprime variables types! Found %i!\n",jprime_var_count);
	}
	for(int i=0;i<jprime_var_count;i++) {
		if(find_substr(jprime_varnames[i],(char*)"Float",t1,t2)) {
			fprintf(h,"#define JPRIME_FLOAT_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"FLOAT\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"Integer",t1,t2)) {
			fprintf(h,"#define JPRIME_LONG_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"INTEGER\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"Opaque",t1,t2)) {
			fprintf(h,"#define JPRIME_OPAQUE_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"OPAQUE\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"String",t1,t2)) {
			fprintf(h,"#define JPRIME_STRING_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"STRING\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"List",t1,t2)) {
			fprintf(h,"#define JPRIME_LIST_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"LIST\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"Symbol",t1,t2)) {
			fprintf(h,"#define JPRIME_SYMBOL_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"SYMBOL\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"Bool",t1,t2)) {
			fprintf(h,"#define JPRIME_BOOL_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"BOOL\")));\n",jprime_varids[i]);
		}
		else if(find_substr(jprime_varnames[i],(char*)"ResourceIdentifier",t1,t2)) {
			fprintf(h,"#define JPRIME_RESOURCE_VAR_ID %i\n",jprime_varids[i]);
			fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"RESOURCE\")));\n",jprime_varids[i]);
		}
		else {
			FATAL("Unknown jprime variable type %s (id:%i)\n",jprime_varnames[i],jprime_varids[i])
		}
		found++;
	}
	if(found != 8) {
		FATAL("Expected to find 8 jprime variable types but found %i. There must have been duplicates!\n",found);
	}
	fprintf(h, "#define JPRIME_PROPERTY %i\n", _JPRIME_PROPERTY);
	fprintf(h, "#define JPRIME_SYMBOL_TABLE %i\n", _JPRIME_SYMBOL_TABLE);
	fprintf(h, "#define JPRIME_PARTITION %i\n", _JPRIME_PARTITION);
	fprintf(h, "#define JPRIME_COMMUNITY %i\n", _JPRIME_COMMUNITY);
	fprintf(h, "#define JPRIME_SYMBOL_TABLE_ENTRY %i\n", _JPRIME_SYMBOL_TABLE_ENTRY);
	fprintf(h, "#define JPRIME_ROUTE_TABLE %i\n", _JPRIME_ROUTE_TABLE);
	fprintf(h, "#define JPRIME_ROUTE_ENTRY %i\n", _JPRIME_ROUTE_ENTRY);
	fprintf(h, "#define JPRIME_GHOST_NODE %i\n", _JPRIME_GHOST_NODE);
	fprintf(h, "#define JPRIME_GENERIC_NODE %i\n", _JPRIME_GENERIC_NODE);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"PROPERTY\")));\n",_JPRIME_PROPERTY);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"SYMBOL_TABLE\")));\n",_JPRIME_SYMBOL_TABLE);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"PARTITION\")));\n",_JPRIME_PARTITION);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"COMMUNITY\")));\n",_JPRIME_COMMUNITY);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"SYMBOL_TABLE_ENTRY\")));\n",_JPRIME_SYMBOL_TABLE_ENTRY);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"ROUTE_TABLE\")));\n",_JPRIME_ROUTE_TABLE);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"ROUTE_ENTRY\")));\n",_JPRIME_ROUTE_ENTRY);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"GHOST_NODE\")));\n",_JPRIME_GHOST_NODE);
	fprintf(cc, "\tjprime_type_names->insert(SSFNET_MAKE_PAIR(%i,new SSFNET_STRING(\"GENERIC_NODE\")));\n",_JPRIME_GENERIC_NODE);
	fprintf(cc, "}\n");
	fprintf(cc, "\nSSFNET_STRING* getJPRIMETypeString(int idx){\n");
	fprintf(cc, "\tif(!jprime_type_names)setup_jprime_type_types();\n");
	fprintf(cc, "\tSSFNET_MAP(int,SSFNET_STRING*)::iterator rv;\n");
	fprintf(cc, "\trv=jprime_type_names->find(idx);\n");
	fprintf(cc, "\tif(rv==jprime_type_names->end()) {\n");
	fprintf(cc, "\t\treturn NULL;\n");
	fprintf(cc, "\t}\n");
	fprintf(cc, "\treturn rv->second;\n");
	fprintf(cc, "}\n");

	fprintf(cc, "\nSSFNET_MAP(SSFNET_STRING,uint32_t)* jprime_attr_ids = 0; \n");
	fprintf(cc, "\nSSFNET_MAP(uint32_t,SSFNET_STRING)* jprime_attr_strings = 0; \n");

	fprintf(cc, "void setupJPRIMEAttrIDs() {\n");
	fprintf(cc, "\tjprime_attr_ids = new SSFNET_MAP(SSFNET_STRING,uint32_t)();\n");
	fprintf(cc, "\tjprime_attr_strings = new SSFNET_MAP(uint32_t, SSFNET_STRING)();\n");
 	for(std::map<uint32_t, std::pair<char*,char*> >::iterator it=var_ids.begin();it!=var_ids.end();it++) {
 		fprintf(cc, "\tjprime_attr_ids->insert(SSFNET_MAKE_PAIR(SSFNET_STRING(\"%s\"),%u));\n", (*it).second.first, (*it).first);
 		fprintf(cc, "\tjprime_attr_strings->insert(SSFNET_MAKE_PAIR(%u,SSFNET_STRING(\"%s\")));\n", (*it).first, (*it).second.first);
 	}
	fprintf(cc, "}\n");

	fprintf(cc, "SSFNET_STRING* getJPRIMEAttrName(uint32_t attr_id) {");
	fprintf(cc, "\tif(!jprime_attr_strings) setupJPRIMEAttrIDs();\n");
	fprintf(cc, "\tSSFNET_MAP(uint32_t,SSFNET_STRING)::iterator rv = jprime_attr_strings->find(attr_id);\n");
	fprintf(cc, "\tif(rv == jprime_attr_strings->end()) return NULL;\n");
	fprintf(cc, "\treturn &(rv->second);\n");
	fprintf(cc, "}\n");

	fprintf(cc, "uint32_t getJPRIMEAttrID(SSFNET_STRING& str){\n");
	fprintf(cc, "\tif(!jprime_attr_ids) setupJPRIMEAttrIDs();\n");
	fprintf(cc, "\tSSFNET_MAP(SSFNET_STRING,uint32_t)::iterator rv = jprime_attr_ids->find(str);\n");
	fprintf(cc, "\tif(rv == jprime_attr_ids->end()) return 0;\n");
	fprintf(cc, "\treturn rv->second;\n");
	fprintf(cc, "}\n");


	cur = root;
	while(cur) {
		if(cur->data && strcmp(cur->data->name,"BaseEntity")) {
			if(!strncmp("src/ssfnet/",cur->data->filename,strlen("src/ssfnet/"))) {
				fprintf(h, "#include \"%s\" ",cur->data->filename+strlen("src/ssfnet/"));
			}
			else {
				fprintf(h, "#include \"%s\" ",cur->data->filename);
			}
			if(cur->data->extends && strlen(cur->data->extends)>0) {
				fprintf(h,"//class %s : public %s ...\n",cur->data->name,cur->data->extends);
			}
			else {
				fprintf(h,"//class %s ...\n",cur->data->name);
			}
		}
		cur=cur->next;
	}
	fprintf(h,"namespace prime {\n");
	fprintf(h,"namespace ssfnet {\n");
	fprintf(h, "\nSSFNET_STRING* getJPRIMETypeString(int idx);\n");
	fprintf(h, "void setupJPRIMEAttrIDs();\n");
	fprintf(h, "uint32_t getJPRIMEAttrID(SSFNET_STRING& str);\n");
	fprintf(h, "SSFNET_STRING* getJPRIMEAttrName(uint32_t attr_id);\n");


	cur = root;
	while(cur) {
		if(cur->data&& strcmp(cur->data->name,"BaseEntity")) {
			gen_common_hdr(cur->data, h);
			gen_common_impl(cur->data, cc);
			if(insert_into_header(cur->data)) {
				//XXX there was an error!
			}
		}
		cur=cur->next;
	}

	fprintf(h,"} //end prime\n");
	fprintf(h,"} //end ssfnet\n");
	fprintf(h,"#endif //__CONFIGURABLE_TYPES_H__\n");


	fprintf(cc,"} //end prime\n");
	fprintf(cc,"} //end ssfnet\n");
	fclose(h);
	fclose(cc);
}


bool file_exists(const char* filename) {
  struct stat stFileInfo;
  bool blnReturn;
  int intStat;

  // Attempt to get the file attributes
  intStat = stat(filename,&stFileInfo);
  if(intStat == 0) {
    // We were able to get the file attributes
    // so the file obviously exists.
    blnReturn = true;
  } else {
    // We were not able to get the file attributes.
    // This may mean that we don't have permission to
    // access the folder which contains this file. If you
    // need to do that level of checking, lookup the
    // return values of stat which will give you
    // more details on why stat failed.
    blnReturn = false;
  }
  return(blnReturn);
}

bool dir_exists( const char* pzPath )
{
    if ( pzPath == NULL) return false;
    DIR *pDir;
    bool bExists = false;
    pDir = opendir (pzPath);
    if (pDir != NULL)
    {
        bExists = true;
        (void) closedir (pDir);
    }
    return bExists;
}
void genIsSubType(FILE* f, config_type_t* c, int idx) {
	char t[50];
	switch(idx) {
	case IMPL_ID:
		t[0]='\0';
		break;
	case ALIAS_ID:
		sprintf(t,"Alias");
		break;
	case REPLICA_ID:
		sprintf(t,"Replica");
		break;
	case ALIAS_REPLICA_ID:
		sprintf(t,"AliasReplica");
		break;
	default:
		sprintf(t,"ERROR");
	}
	fprintf(f,"\t\t\tcase %i: //%s%s\n", c->auto_type_ids[idx],c->name,t);
	 config_type_t* cur=c->first_sub_type;
	 while(cur) {
		 genIsSubType(f,cur,idx);
		 cur=cur->next;
	 }
}

void genAttrAccessors(FILE* f, config_type_t* t, bool is_replica, bool is_alias, bool is_interface) {
	config_var_t* cur_var=t->first_var;
	char ctype[200];
	char ctype1[200];
	if(!(is_interface||is_alias||is_replica)) {
		fprintf(f,"\tpublic final static java.util.ArrayList<Integer> attrIds=new java.util.ArrayList<Integer>();\n");
		fprintf(f,"\tstatic {\n");
		while(cur_var) {
			if(cur_var->is_configurable) {
				fprintf(f,"\t\tattrIds.add(%li);\n",cur_var->var_id);
			}
			cur_var=cur_var->next;
		}
		fprintf(f,"\t}\n");
	}
	cur_var=t->first_var;
	while(cur_var) {
		if(cur_var->is_configurable) {
			ctype1[0]='\0';
			if(!cur_var->config_type) {
				sprintf(ctype,"ITS_NULL");
			}
			else if(!strcmp("STRING",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.StringVariable");
			}
			else if(!strcmp("OBJECT",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.OpaqueVariable");
			}
			else if(!strcmp("INT",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.IntegerVariable");
				sprintf(ctype1,"long");
			}
			else if(!strcmp("FLOAT",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.FloatingPointNumberVariable");
				sprintf(ctype1,"float");
			}
			else if(!strcmp("BOOL",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.BooleanVariable");
				sprintf(ctype1,"boolean");
			}
			else if(!strcmp("LIST",cur_var->config_type)) {
				sprintf(ctype,"jprime.variable.ListVariable");
				sprintf(ctype1,"java.util.List<ModelNodeVariable>");
			}
			else if(!strcmp("RESOURCE_ID",cur_var->config_type)) {
				sprintf(ctype,"ResourceIdentifierVariable");
				sprintf(ctype1,"jprime.ResourceIdentifier.ResourceID");
			}
			else {
				FATAL("Unknown variable type '%s'\n",cur_var->config_type);
			}
#if 0
			/** XXX MOVED TO FIX ATTR NAME **/
			std::string str;
			str.append(cur_var->name);
			str[0]=toupper(str[0]);
			int pos = str.find('_');
			while(pos<str.length()){
				if(pos+1<str.length())
					str[pos+1]=toupper(str[pos+1]);
				for(int j=pos+1;j<str.length();j++) {
					str[j-1]=str[j];
				}
				str.erase(str.length()-1,1);
				pos = str.find('_',pos+1);
			}
#endif
			std::string str = fixAttrName(cur_var->name);
			fprintf(f,"\n\t/**\n");
			if(cur_var->doc_string)
				fprintf(f,"\t * @return %s\n",cur_var->doc_string);
			else
				fprintf(f,"\t * @return <no doc_string>\n");
			fprintf(f,"\t */\n");
			fprintf(f,"\tpublic %s get%s()",
					ctype,
					str.c_str());
			if(is_interface) {
				fprintf(f,";\n");
			}
			else {
				fprintf(f," {\n");
				if(is_alias) {
					fprintf(f,"\t\treturn (%s)((I%s)deference()).get%s();\n",
							ctype,
							t->name,
							str.c_str());
				}
				else if(is_replica){
					fprintf(f,"\t\t%s temp = (%s)getAttributeByName(ModelNodeVariable.%s());\n",
							ctype,
							ctype,
							cur_var->name);
					fprintf(f,"\t\tif(null!=temp) return temp;\n");
					fprintf(f,"\t\treturn (%s)this.getReplicatedNode().getAttributeByName(ModelNodeVariable.%s());\n",
							ctype,
							cur_var->name);
				}
				else {
					fprintf(f,"\t\treturn (%s)getAttributeByName(ModelNodeVariable.%s());\n",
							ctype,
							cur_var->name);
				}
				fprintf(f,"\t}\n");
			}

			fprintf(f,"\n\t/**\n");
			fprintf(f,"\t * Set the attribute to the static value 'value'.\n");
			fprintf(f,"\t * @param value the value\n");
			fprintf(f,"\t */\n");
			fprintf(f,"\tpublic void set%s(String value)",
					str.c_str());
			if(is_interface) {
				fprintf(f,";\n");
			}
			else {
				fprintf(f," {\n");
				if(is_alias) {
					fprintf(f,"\t\t((I%s)deference()).set%s(value);\n",
							t->name,
							str.c_str());
				}
				else {
					fprintf(f,"\t\tjprime.variable.ModelNodeVariable temp = getAttributeByName(jprime.gen.ModelNodeVariable.%s());\n",
							cur_var->name);

					fprintf(f,"\t\tif(temp==null){\n");
					fprintf(f,"\t\t\ttemp=new %s(jprime.gen.ModelNodeVariable.%s(),value);\n",
							ctype,
							cur_var->name);
					fprintf(f,"\t\t\taddAttr(temp);\n");
					fprintf(f,"\t\t}\n");
					fprintf(f,"\t\telse{\n");
					fprintf(f,"\t\t\tif(! (temp instanceof %s)){\n",ctype);
#if JPRIME_SEPARATE_PROP_TABLE
					fprintf(f,"\t\t\t\tgetMetadata().remove(this, temp);\n");
#endif
					fprintf(f,"\t\t\t\ttemp=new %s(jprime.gen.ModelNodeVariable.%s(),value);\n",
							ctype,
							cur_var->name);
					fprintf(f,"\t\t\t\taddAttr(temp);\n");
					fprintf(f,"\t\t\t}\n");
					fprintf(f,"\t\t\telse { ((%s)temp).setValue(value); }\n",ctype);
					fprintf(f,"\t\t}\n");
				}
				fprintf(f,"\t}\n");
			}
			if(strlen(ctype1)>0) {
				fprintf(f,"\n\t/**\n");
				fprintf(f,"\t * Set the attribute to the static value 'value'.\n");
				fprintf(f,"\t * @param value the value\n");
				fprintf(f,"\t */\n");
				fprintf(f,"\tpublic void set%s(%s value)",
						str.c_str(),
						ctype1);
				if(is_interface) {
					fprintf(f,";\n");
				}
				else {
					fprintf(f," {\n");
					if(is_alias) {
						fprintf(f,"\t\t((I%s)deference()).set%s(value);\n",
								t->name,
								str.c_str());
					}
					else {
						fprintf(f,"\t\tjprime.variable.ModelNodeVariable temp = getAttributeByName(jprime.gen.ModelNodeVariable.%s());\n",
								cur_var->name);

						fprintf(f,"\t\tif(temp==null){\n");
						fprintf(f,"\t\t\ttemp=new %s(jprime.gen.ModelNodeVariable.%s(),value);\n",
								ctype,
								cur_var->name);
						fprintf(f,"\t\t\taddAttr(temp);\n");
						fprintf(f,"\t\t}\n");
						fprintf(f,"\t\telse{\n");
						fprintf(f,"\t\t\tif(! (temp instanceof %s)){\n",ctype);
#if JPRIME_SEPARATE_PROP_TABLE
						fprintf(f,"\t\t\t\tgetMetadata().remove(this, temp);\n");
#endif
						fprintf(f,"\t\t\t\ttemp=new %s(jprime.gen.ModelNodeVariable.%s(),value);\n",
								ctype,
								cur_var->name);
						fprintf(f,"\t\t\t\taddAttr(temp);\n");
						fprintf(f,"\t\t\t}\n");
						fprintf(f,"\t\t\telse { ((%s)temp).setValue(value); }\n",ctype);
						fprintf(f,"\t\t}\n");
					}
					fprintf(f,"\t}\n");
				}
			}
			fprintf(f,"\n\t/**\n");
			fprintf(f,"\t * Have the attribute be bound to the value of the symbol at model instantiation.\n");
			fprintf(f,"\t * @param value the value\n");
			fprintf(f,"\t */\n");
			fprintf(f,"\tpublic void set%s(jprime.variable.SymbolVariable value)",
					str.c_str());
			if(is_interface) {
				fprintf(f,";\n");
			}
			else {
				fprintf(f," {\n");
				if(is_alias) {
					fprintf(f,"\t\t((I%s)deference()).set%s(value);\n",
							t->name,
							str.c_str());
				}
				else {
					fprintf(f,"\t\tif(value==null)throw new RuntimeException(\"attr was null\");\n");
					fprintf(f,"\t\tif(value.getDBName() != -1) throw new RuntimeException(\"the attr was already attached to another model node!\");\n");
#if JPRIME_SEPARATE_PROP_TABLE
					fprintf(f,"\t\tjprime.variable.ModelNodeVariable temp = getAttributeByName(jprime.gen.ModelNodeVariable.%s());\n",
							cur_var->name);
					fprintf(f,"\t\tif(temp!=null){\n");
					fprintf(f,"\t\t\tgetMetadata().remove(this, temp);\n");
					fprintf(f,"\t\t}\n");
#endif
					fprintf(f,"\t\tvalue.attachToNode(this,jprime.gen.ModelNodeVariable.%s());\n",
							cur_var->name);
					fprintf(f,"\t\taddAttr(value);\n");

				}
				fprintf(f,"\t}\n");
			}
		}
		cur_var=cur_var->next;
	}
	fprintf(f, "\n\t/**\n");
	fprintf(f, "\t * @return a list of ids of the possible type of attribute this model node type can have\n");
	fprintf(f, "\t */\n");
	fprintf(f,"\tpublic java.util.ArrayList<Integer> getAttrIds()");
	if(is_interface) {
		fprintf(f,";\n");
	}
	else {
		fprintf(f," {\n");
		if(is_replica || is_alias) {
			fprintf(f,"\t\treturn jprime.gen.%s.attrIds;\n",t->name);
		}
		else {
			fprintf(f,"\t\treturn attrIds;\n");
		}
		fprintf(f,"\t}\n");
	}
}
void generateChildLists(FILE* f, config_type_t* t) {
	config_child_t* ct=t->first_child;
#if 0
	while(ct) {
		if(!ct->the_type) {
			FATAL("should never see this\n");
		}

		fprintf(f,"\n\t/* %s */\n", ct->doc_string);
		fprintf(f,"\tprivate jprime.util.ChildList<jprime.%s.I%s%s> cl__%s__;\n",
				ct->c_type,
				ct->c_type,
				(ct->is_aliased?"Alias":""),
				ct->name);
		ct=ct->next;
	}
	ct=t->first_child;
	fprintf(f,"\n\t/* used to initialize the child_lists */\n");
	fprintf(f,"\n\tprotected void setupChildLists() {\n");
	while(ct) {
		fprintf(f,"\t\tcl__%s__ = new jprime.util.ChildList<jprime.%s.I%s%s>(this, %i, %s, %s);\n",
				ct->name,
				ct->c_type,
				ct->c_type,
				(ct->is_aliased?"Alias":""),
				ct->the_type->auto_type_ids[IMPL_ID],
				ct->min,
				ct->max);
		ct=ct->next;
	}
	fprintf(f,"\t\tsuper.setupChildLists();\n");
	fprintf(f,"\n\t}\n");
	ct=t->first_child;

	fprintf(f, "\n\t/**\n");
	fprintf(f, "\t * @param kid the child to add\n");
	fprintf(f, "\t */\n");
	fprintf(f,"\n\tprotected void addChildToChildLists(IModelNode kid) {\n");
	ct=t->first_child;
	while(ct) {
		fprintf(f,"\t\tcl__%s__.addChild(kid);\n", ct->name);
		ct=ct->next;
	}
	fprintf(f,"\t\tsuper.addChildToChildLists(kid);\n");
	fprintf(f,"\n\t}\n");
#endif

	fprintf(f,"\n\t/* used to enforce the minimum/maximum child requirement */\n");
	fprintf(f,"\n\tpublic void enforceChildConstraints() {\n");
	fprintf(f,"\t\tsuper.enforceChildConstraints();\n");
	while(ct) {
		fprintf(f,"\tget%c%s().enforceChildConstraints();",
						toupper(ct->name[0]),
						ct->name+1);
		ct=ct->next;
	}
	fprintf(f,"\n\t}\n");
}

void generateChildAccessor(FILE* f, config_child_t* ct, bool addEnumerate, bool is_replica, bool is_alias, bool is_interface) {
	//*****************************
	if(ct->is_aliased) {
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%sAlias, which points to to_alias, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param to_alias the node to point to\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%s(jprime.%s.I%s to_alias)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\treturn create%s(null,to_alias);\n",
						ct->the_type->name);
			}
			fprintf(f,"\t}\n");
		}
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * jython method to create a a new child of type jprime.%s.%sAlias, which points to to_alias, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param to_alias the node to point to\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");

		fprintf(f,"\tpublic jprime.%s.I%s create%s(PyObject[] v, String[] n)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tif(jprime.ModelNode.__hasReplicate(v,n,%s)) {\n",(ct->is_aliased?"true":"false"));
				fprintf(f,"\t\t\tPyObject[] v1 = new PyObject[v.length+1];\n");
				fprintf(f,"\t\t\tfor(int i=0;i<v.length;i++)v1[i+1]=v[i];\n");
				fprintf(f,"\t\t\tv1[0]=Py.java2py(this);\n");
				fprintf(f,"\t\t\tjprime.%s.%sAliasReplica temp = new jprime.%s.%sAliasReplica(v1,n);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\t\taddChild(temp);\n");
				fprintf(f,"\t\t\treturn temp;\n");
				fprintf(f,"\t\t} else {\n");
				fprintf(f,"\t\t\tPyObject[] v1 = new PyObject[v.length+1];\n");
				fprintf(f,"\t\t\tfor(int i=0;i<v.length;i++)v1[i+1]=v[i];\n");
				fprintf(f,"\t\t\tv1[0]=Py.java2py(this);\n");
				fprintf(f,"\t\t\tjprime.%s.%sAlias temp = new jprime.%s.%sAlias(v1,n);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\t\taddChild(temp);\n");
				fprintf(f,"\t\t\treturn temp;\n");
				fprintf(f,"\t\t}\n");
			}
			fprintf(f,"\t}\n");
		}
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%sAlias, which points to to_alias, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param name the name to assign the new node\n");
		fprintf(f,"\t  * @param to_alias the node to point to\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%s(String name, jprime.%s.I%s to_alias)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tjprime.%s.%sAlias temp = new jprime.%s.%sAlias(this,to_alias);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\ttemp.setName(name);\n");
				fprintf(f,"\t\taddChild(temp);\n");
			}
		}
	}
	else {
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%s and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%s()",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\treturn create%s(null);\n",
						ct->the_type->name);
			}
			fprintf(f,"\t}\n");
		}
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * jython method to create a a new child of type jprime.%s.%s, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%s(PyObject[] v, String[] n)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tif(jprime.ModelNode.__hasReplicate(v,n,%s)) {\n",(ct->is_aliased?"true":"false"));
				fprintf(f,"\t\t\tPyObject[] v1 = new PyObject[v.length+1];\n");
				fprintf(f,"\t\t\tfor(int i=0;i<v.length;i++)v1[i+1]=v[i];\n");
				fprintf(f,"\t\t\tv1[0]=Py.java2py(this);\n");
				fprintf(f,"\t\t\tjprime.%s.%sReplica temp = new jprime.%s.%sReplica(v1,n);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\t\taddChild(temp);\n");
				fprintf(f,"\t\t\treturn temp;\n");
				fprintf(f,"\t\t} else {\n");
				fprintf(f,"\t\t\tPyObject[] v1 = new PyObject[v.length+1];\n");
				fprintf(f,"\t\t\tfor(int i=0;i<v.length;i++)v1[i+1]=v[i];\n");
				fprintf(f,"\t\t\tv1[0]=Py.java2py(this);\n");
				fprintf(f,"\t\t\tjprime.%s.%s temp = new jprime.%s.%s(v1,n);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\t\taddChild(temp);\n");
				fprintf(f,"\t\t\treturn temp;\n");
				fprintf(f,"\t\t}\n");
			}
			fprintf(f,"\t}\n");

		}

		fprintf(f,"\n\t /**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%s and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param name the name to assign the new node\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%s(String name)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tjprime.%s.%s temp = new jprime.%s.%s(this);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\ttemp.setName(name);\n");
				fprintf(f,"\t\taddChild(temp);\n");
			}
		}
	}
	if(!is_interface) {
		if(!is_alias) {
			fprintf(f,"\t\treturn temp;\n");
		}
		fprintf(f,"\t}\n");
	}
	//*****************************
	//*****************************
	if(ct->is_aliased) {
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * Add a new child of type jprime.%s.%sAlias\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic void add%sAlias(jprime.%s.%sAlias kid)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\taddChild(kid);\n");
			}
			fprintf(f,"\t}\n");
		}
	}
	else {
		fprintf(f,"\n\t /**\n");
		fprintf(f,"\t  * Add a new child of type jprime.%s.%s.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic void add%s(jprime.%s.%s kid)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\taddChild(kid);\n");
			}
			fprintf(f,"\t}\n");
		}
	}
	//*****************************
	//*****************************
	if(!ct->is_aliased) {
		fprintf(f,"\n\t /**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%sReplica, which is a deep-lightweight copy of to_replicate, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param to_replicate the node which is to be deep copied\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%sReplica(jprime.%s.I%s to_replicate)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tjprime.%s.%sReplica temp = new jprime.%s.%sReplica(null, this,to_replicate);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\taddChild(temp);\n");
				fprintf(f,"\t\treturn temp;\n");
			}
			fprintf(f,"\t}\n");
		}
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * jython method to create replica new child of type jprime.%s.%sReplica, which points to to_alias, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param to_alias the node to point to\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s replicate%s(PyObject[] v, String[] n)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tPyObject[] v1 = new PyObject[v.length+1];\n");
				fprintf(f,"\t\tfor(int i=0;i<v.length;i++)v1[i+1]=v[i];\n");
				fprintf(f,"\t\tv1[0]=Py.java2py(this);\n");
				fprintf(f,"\t\tjprime.%s.%sReplica temp = new jprime.%s.%sReplica(v1,n);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\taddChild(temp);\n");
				fprintf(f,"\t\treturn temp;\n");
			}
			fprintf(f,"\t}\n");

		}

		fprintf(f,"\n\t /**\n");
		fprintf(f,"\t  * Create a new child of type jprime.%s.%sReplica, which is a deep-lightweight copy of to_replicate, and add it as a child to this node.\n", ct->the_type->name, ct->the_type->name);
		fprintf(f,"\t  * @param name the name to assign the new node\n");
		fprintf(f,"\t  * @param to_replicate the node which is to be deep copied\n");
		fprintf(f,"\t  * @return the new child\n");
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.%s.I%s create%sReplica(String name, jprime.%s.I%s to_replicate)",
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name,
				ct->the_type->name);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
			}
			else {
				fprintf(f,"\t\tjprime.%s.%sReplica temp = new jprime.%s.%sReplica(name, this,to_replicate);\n",
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name,
						ct->the_type->name);
				fprintf(f,"\t\taddChild(temp);\n");
				fprintf(f,"\t\treturn temp;\n");
			}
			fprintf(f,"\t}\n");
		}
	}
	//*****************************
	//*****************************
	if(addEnumerate) {
		fprintf(f,"\n\t/**\n");
		fprintf(f,"\t  * return %s\n",ct->doc_string);
		fprintf(f,"\t  */\n");
		fprintf(f,"\tpublic jprime.util.ChildList<jprime.%s.I%s%s> get%c%s()",
				ct->the_type->name,
				ct->the_type->name,
				(ct->is_aliased?"Alias":""),
				toupper(ct->name[0]),
				ct->name+1);
		if(is_interface) {
			fprintf(f,";\n");
		}
		else {
			fprintf(f," {\n");
			if(is_alias) {
				fprintf(f,"\t\tthrow new RuntimeException(\"Aliases do not have children!\");\n");
			}
			else {
				fprintf(f,"\t\treturn new jprime.util.ChildList<jprime.%s.I%s%s>(this, %i, %s, %s);\n",
						ct->c_type,
						ct->c_type,
						(ct->is_aliased?"Alias":""),
						ct->the_type->auto_type_ids[IMPL_ID],
						ct->min,
						ct->max);
			}
			fprintf(f,"\t}\n");
		}
	}
}

void generateChildAccessors(FILE* f, config_type_t* t, bool is_replica, bool is_alias, bool is_interface) {
	/*printf("Generating generateChildAccessors for %s, is_replica=%s, is_alias=%s, is_interface=%s\n",
			t->name,
			(is_replica?"TRUE":"FALSE"),
			(is_alias?"TRUE":"FALSE"),
			(is_interface?"TRUE":"FALSE")
			);*/
	config_child_t* ct=t->first_child;
	while(ct) {
		if(!ct->the_type) {
			FATAL("should never see this\n");
		}
		generateChildAccessor(f,ct,true,is_replica,is_alias,is_interface);
		config_type_t* prev=ct->the_type;

		std::list<config_type_t*> subs;
		if(ct->the_type->first_sub_type)
			subs.push_back(ct->the_type->first_sub_type);
		while(subs.size()>0) {
			ct->the_type=subs.front();
			subs.pop_front();
			//printf("\tct->the_type=%s\n",ct->the_type->name);
			generateChildAccessor(f,ct,false, is_replica,is_alias,is_interface);
			if(ct->the_type->next)
				subs.push_back(ct->the_type->next);
			if(ct->the_type->first_sub_type)
				subs.push_back(ct->the_type->first_sub_type);
		}
		/*
		while(st) {
			printf("\tct->the_type=%s, st=%s\n",ct->the_type->name,st->name);
			ct->the_type=st;
			generateChildAccessor(f,ct,false, is_replica,is_alias,is_interface);
			st=st->next;
		}*/
		ct->the_type=prev;
		ct=ct->next;
	}
}

void generateJavaType(char* jprime_dir, config_type_t* t) {
	if(!strcmp(t->name,"Alias")) {
		//we dont want to generate code for aliases!
		return;
	}
	char ModelNode[]="ModelNode";
	char* BaseEntity=NULL;
	if(!strcmp("BaseEntity",t->extends)) {
		BaseEntity=t->extends;
		t->extends=ModelNode;
	}
	FILE *iface, *alias_iface, *impl, *alias, *replica, *alias_replica;
	char temp[strlen(jprime_dir)+strlen(t->name)+50];

	sprintf(temp,"%s/gen",jprime_dir);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}

	sprintf(temp,"%s/gen/I%s.java",jprime_dir,t->name);
	iface = fopen(temp, "w");
 	if(iface==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	sprintf(temp,"%s/gen/I%sAlias.java",jprime_dir,t->name);
	alias_iface = fopen(temp, "w");
 	if(alias_iface==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	sprintf(temp,"%s/gen/%s.java",jprime_dir,t->name);
	impl = fopen(temp, "w");
 	if(impl==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	sprintf(temp,"%s/gen/%sAlias.java",jprime_dir,t->name);
	alias = fopen(temp, "w");
 	if(alias==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	sprintf(temp,"%s/gen/%sReplica.java",jprime_dir,t->name);
	replica = fopen(temp, "w");
 	if(replica==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	sprintf(temp,"%s/gen/%sAliasReplica.java",jprime_dir,t->name);
	alias_replica = fopen(temp, "w");
 	if(alias_replica==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}

	write_warning(iface);
	write_warning(alias_iface);
	write_warning(impl);
	write_warning(alias);
	write_warning(replica);
	write_warning(alias_replica);

	/**
	 * The interface...
	 */
	fprintf(iface,"\npackage jprime.gen;\n\n");
	fprintf(iface,"import jprime.*;\n");
	fprintf(iface,"import jprime.variable.*;\n");
	fprintf(iface,"import org.python.core.PyObject;\n");

	if(!strcmp("ModelNode",t->extends))
		fprintf(iface,"public interface I%s extends jprime.I%s {\n",t->name, t->extends);
	else
		fprintf(iface,"public interface I%s extends jprime.%s.I%s {\n",t->name, t->extends, t->extends);
	genAttrAccessors(iface,t,false,false,true);
	generateChildAccessors(iface,t,false,false,true);
	fprintf(iface,"}\n");

	/**
	 * The alias interface...
	 */
	fprintf(alias_iface,"\npackage jprime.gen;\n\n");

	if(!strcmp("ModelNode",t->extends))
		fprintf(alias_iface,"public interface I%sAlias extends jprime.%s.I%s {\n", t->name, t->name, t->name);
	else
		fprintf(alias_iface,"public interface I%sAlias extends jprime.%s.I%s, jprime.%s.I%sAlias {\n",  t->name, t->name,t->name, t->extends, t->extends);
	fprintf(alias_iface,"}\n");


	/**
	 * The impl...
	 */
	fprintf(impl,"\npackage jprime.gen;\n\n");
	fprintf(impl,"import jprime.*;\n");
	fprintf(impl,"import jprime.variable.*;\n");
	fprintf(impl,"import jprime.ModelNodeRecord;\n");
	fprintf(impl,"import org.python.core.PyObject;\n");
	fprintf(impl,"import org.python.core.Py;\n");

	if(!strcmp("ModelNode",t->extends)) {
		fprintf(impl,"public abstract class %s extends jprime.%s implements jprime.gen.I%s {\n", t->name, t->extends, t->name);
	}
	else {
		fprintf(impl,"public abstract class %s extends jprime.%s.%s implements jprime.gen.I%s {\n", t->name, t->extends, t->extends, t->name);
	}
	generateChildLists(impl,t);
	fprintf(impl,"\tpublic %s(PyObject[] v, String[] s){super(v,s);}\n",t->name);
	fprintf(impl,"\tpublic %s(ModelNodeRecord rec){ super(rec); }\n",t->name);
	fprintf(impl,"\tpublic %s(IModelNode parent){ super(parent); }\n",t->name);

	fprintf(impl,"\t/**\n");
	fprintf(impl,"\t * @return the interface which this node implements\n");
	fprintf(impl,"\t */\n");
	fprintf(impl,"\tpublic Class<?> getNodeType() {\n");
	fprintf(impl,"\t\treturn jprime.%s.I%s.class;\n",t->name,t->name);
	fprintf(impl,"\t}\n");

	fprintf(impl,"\t/**\n");
	fprintf(impl,"\t * @param used by replicas to do a deep copy of the node.\n");
	fprintf(impl,"\t */\n");
	fprintf(impl,"\tpublic jprime.ModelNode deepCopy(jprime.ModelNode parent) {\n");
	fprintf(impl,"\t\tjprime.%s.%sReplica c = new jprime.%s.%sReplica(this.getName(),(IModelNode)parent,(jprime.%s.I%s)this);\n",t->name,t->name,t->name,t->name,t->name,t->name);
	fprintf(impl,"\t\treturn c;\n");
	fprintf(impl,"\t}\n");

	fprintf(impl,"\tpublic static boolean isSubType(IModelNode n) {\n");
	fprintf(impl,"\t\treturn isSubType(n.getTypeId());\n");
	fprintf(impl,"\t}\n");
	fprintf(impl,"\tpublic static boolean isSubType(int id) {\n");
	fprintf(impl,"\t\tswitch(id) {\n");
	genIsSubType(impl,t,IMPL_ID);
	genIsSubType(impl,t,ALIAS_ID);
	genIsSubType(impl,t,REPLICA_ID);
	genIsSubType(impl,t,ALIAS_REPLICA_ID);
	fprintf(impl,"\t\t\t\treturn true;\n");
	fprintf(impl,"\t\t}\n");
	fprintf(impl,"\t\treturn false;\n");
	fprintf(impl,"\t}\n");
	fprintf(impl, "\n\t/* (non-Javadoc)\n");
	fprintf(impl, "\t* @see jprime.IModelNode#getTypeId()\n");
	fprintf(impl, "\t */\n");
	fprintf(impl,"\tpublic abstract int getTypeId();\n");
	genAttrAccessors(impl,t,false,false,false);
	generateChildAccessors(impl,t,false,false,false);
	fprintf(impl, "\n\t/**\n");
	fprintf(impl, "\t * @param visitor a generic visitor\n");
	fprintf(impl, "\t */\n");
	fprintf(impl,"\tpublic abstract void accept(jprime.visitors.IGenericVisitor visitor);\n");
	fprintf(impl,"}\n");

	/**
	 * The alias...
	 */
	fprintf(alias,"\npackage jprime.gen;\n\n");
	fprintf(alias,"import jprime.*;\n");
	fprintf(alias,"import jprime.ModelNodeRecord;\n");
	fprintf(alias,"import jprime.variable.*;\n");
	fprintf(alias,"import org.python.core.PyObject;\n");
	fprintf(alias,"import org.python.core.Py;\n");

	if(!strcmp("ModelNode",t->extends)) {
		fprintf(alias,"public abstract class %sAlias extends jprime.%sAlias implements jprime.gen.I%sAlias {\n", t->name, t->extends, t->name);
		fprintf(alias,"\tpublic %sAlias(IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(alias,"\t\tsuper(parent,(IModelNode)referencedNode);\n");
	}
	else {
		fprintf(alias,"public abstract class %sAlias extends jprime.%s.%sAlias implements jprime.gen.I%sAlias {\n", t->name, t->extends, t->extends, t->name);
		fprintf(alias,"\tpublic %sAlias(IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(alias,"\t\tsuper(parent,(jprime.%s.I%s)referencedNode);\n", t->name, t->name);
	}
	fprintf(alias,"\t}\n");
	fprintf(alias,"\tpublic %sAlias(ModelNodeRecord rec){ super(rec); }\n",t->name);
	fprintf(alias,"\tpublic %sAlias(PyObject[] v, String[] s){super(v,s);}\n",t->name);
	fprintf(alias,"\tpublic %sAlias(IModelNode parent){\n\t\tsuper(parent);\n\t}\n",t->name);

	fprintf(alias,"\t/**\n");
	fprintf(alias,"\t * @return the interface which this node implements\n");
	fprintf(alias,"\t */\n");
	fprintf(alias,"\tpublic Class<?> getNodeType() {\n");
	fprintf(alias,"\t\treturn jprime.%s.I%s.class;\n",t->name,t->name);
	fprintf(alias,"\t}\n");

	fprintf(alias,"\t/**\n");
	fprintf(alias,"\t * @param used by replicas to do a deep copy of the node.\n");
	fprintf(alias,"\t */\n");
	fprintf(alias,"\tpublic jprime.ModelNode deepCopy(jprime.ModelNode parent) {\n");
	fprintf(alias,"\t\tjprime.%s.%sAliasReplica c = new jprime.%s.%sAliasReplica(this.getName(),(IModelNode)parent,this);\n",t->name,t->name,t->name,t->name);
	fprintf(alias,"\t\treturn c;\n");
	fprintf(alias,"\t}\n");

	fprintf(alias,"\tpublic static boolean isSubType(IModelNode n) {\n");
	fprintf(alias,"\t\treturn isSubType(n.getTypeId());\n");
	fprintf(alias,"\t}\n");
	fprintf(alias,"\tpublic static boolean isSubType(int id) {\n");
	fprintf(alias,"\t\tswitch(id) {\n");
	//genIsSubType(alias,t,IMPL_ID);
	genIsSubType(alias,t,ALIAS_ID);
	genIsSubType(alias,t,ALIAS_REPLICA_ID);
	fprintf(alias,"\t\t\t\treturn true;\n");
	fprintf(alias,"\t\t}\n");
	fprintf(alias,"\t\treturn false;\n");
	fprintf(alias,"\t}\n");
	fprintf(alias, "\n\t/* (non-Javadoc)\n");
	fprintf(alias, "\t* @see jprime.IModelNode#getTypeId()\n");
	fprintf(alias, "\t */\n");
	fprintf(alias,"\tpublic abstract int getTypeId();\n");
	genAttrAccessors(alias,t,false,true,false);
	generateChildAccessors(alias,t,false,true,false);
	fprintf(alias, "\n\t/**\n");
	fprintf(alias, "\t * @param kid the child to add\n");
	fprintf(alias, "\t */\n");
#if 0
	fprintf(alias,"\tprotected void addChildToChildLists(IModelNode kid){\n");
	fprintf(alias,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
	fprintf(alias,"\t}\n");
	fprintf(alias,"\tprotected void setupChildLists() {/* there are none! */ }\n");
#endif
	fprintf(alias, "\n\t/**\n");
	fprintf(alias, "\t * @param visitor a generic visitor\n");
	fprintf(alias, "\t */\n");
	fprintf(alias,"\tpublic abstract void accept(jprime.visitors.IGenericVisitor visitor);\n");
	fprintf(alias,"}\n");


	/**
	 * The replica...
	 */
	fprintf(replica,"\npackage jprime.gen;\n\n");
	fprintf(replica,"import jprime.*;\n");
	fprintf(replica,"import jprime.variable.*;\n");
	fprintf(replica,"import jprime.ModelNodeRecord;\n");
	fprintf(replica,"import org.python.core.PyObject;\n");
	fprintf(replica,"import org.python.core.Py;\n");
	if(!strcmp("ModelNode",t->extends)) {
		fprintf(replica,"public abstract class %sReplica extends jprime.%sReplica implements jprime.gen.I%s {\n", t->name, t->extends, t->name);
		generateChildLists(replica,t);
		fprintf(replica,"\tpublic %sReplica(String name, IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(replica,"\t\tsuper(name,parent,referencedNode);\n");
	} else {
		fprintf(replica,"public abstract class %sReplica extends jprime.%s.%sReplica implements jprime.gen.I%s {\n", t->name, t->extends, t->extends, t->name);
		generateChildLists(replica,t);
		fprintf(replica,"\tpublic %sReplica(String name, IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(replica,"\t\tsuper(name,parent,referencedNode);\n");
	}
	fprintf(replica,"\t}\n");
	fprintf(replica,"\tpublic %sReplica(ModelNodeRecord rec){ super(rec); }\n",t->name);
	fprintf(replica,"\tpublic %sReplica(PyObject[] v, String[] s){super(v,s);}\n",t->name);

	fprintf(replica,"\t/**\n");
	fprintf(replica,"\t * @return the interface which this node implements\n");
	fprintf(replica,"\t */\n");
	fprintf(replica,"\tpublic Class<?> getNodeType() {\n");
	fprintf(replica,"\t\treturn jprime.%s.I%s.class;\n",t->name,t->name);
	fprintf(replica,"\t}\n");

	fprintf(replica,"\t/**\n");
	fprintf(replica,"\t * @param used by replicas to do a deep copy of the node.\n");
	fprintf(replica,"\t */\n");
	fprintf(replica,"\tpublic jprime.ModelNode deepCopy(jprime.ModelNode parent) {\n");
	fprintf(replica,"\t\tdoing_deep_copy=true;\n");
	fprintf(replica,"\t\tjprime.%s.%sReplica c = new jprime.%s.%sReplica(this.getName(), (IModelNode)parent,(jprime.%s.I%s)this);\n",t->name,t->name,t->name,t->name,t->name,t->name);
	fprintf(replica,"\t\tdoing_deep_copy=false;\n");
	fprintf(replica,"\t\treturn c;\n");
	fprintf(replica,"\t}\n");

	fprintf(replica,"\tpublic static boolean isSubType(IModelNode n) {\n");
	fprintf(replica,"\t\treturn isSubType(n.getTypeId());\n");
	fprintf(replica,"\t}\n");
	fprintf(replica,"\tpublic static boolean isSubType(int id) {\n");
	fprintf(replica,"\t\tswitch(id) {\n");
	//genIsSubType(replica,t,IMPL_ID);
	genIsSubType(replica,t,REPLICA_ID);
	genIsSubType(replica,t,ALIAS_REPLICA_ID);
	fprintf(replica,"\t\t\t\treturn true;\n");
	fprintf(replica,"\t\t}\n");
	fprintf(replica,"\t\treturn false;\n");
	fprintf(replica,"\t}\n");
	fprintf(replica, "\n\t/* (non-Javadoc)\n");
	fprintf(replica, "\t* @see jprime.IModelNode#getTypeId()\n");
	fprintf(replica, "\t */\n");
	fprintf(replica,"\tpublic abstract int getTypeId();\n");
	genAttrAccessors(replica,t,true,false,false);
	generateChildAccessors(replica,t,true,false,false);
	fprintf(replica, "\n\t/**\n");
	fprintf(replica, "\t * @param visitor a generic visitor\n");
	fprintf(replica, "\t */\n");
	fprintf(replica,"\tpublic abstract void accept(jprime.visitors.IGenericVisitor visitor);\n");
	fprintf(replica,"}\n");


	/**
	 * The alias_replica...
	 */
	fprintf(alias_replica,"\npackage jprime.gen;\n\n");
	fprintf(alias_replica,"import jprime.*;\n");
	fprintf(alias_replica,"import jprime.variable.*;\n");
	fprintf(alias_replica,"import jprime.ModelNodeRecord;\n");
	fprintf(alias_replica,"import org.python.core.PyObject;\n");
	fprintf(alias_replica,"import org.python.core.Py;\n");

	if(!strcmp("ModelNode",t->extends)) {
		fprintf(alias_replica,"public abstract class %sAliasReplica extends jprime.%sAliasReplica implements jprime.gen.I%sAlias {\n", t->name, t->extends, t->name);
		fprintf(alias_replica,"\tpublic %sAliasReplica(String name, IModelNode parent, jprime.ModelNodeAlias referencedNode) {\n", t->name);
		fprintf(alias_replica,"\t\tsuper(name,parent,referencedNode);\n");
	}
	else {
		fprintf(alias_replica,"public abstract class %sAliasReplica extends jprime.%s.%sAliasReplica implements jprime.gen.I%sAlias {\n", t->name, t->extends, t->extends, t->name);
		fprintf(alias_replica,"\tpublic %sAliasReplica(String name, IModelNode parent, jprime.ModelNodeAlias referencedNode) {\n", t->name);
		fprintf(alias_replica,"\t\tsuper(name, parent,referencedNode);\n");
	}
	fprintf(alias_replica,"\t}\n");
	fprintf(alias_replica,"\tpublic %sAliasReplica(ModelNodeRecord rec){ super(rec); }\n",t->name);
	fprintf(alias_replica,"\tpublic %sAliasReplica(PyObject[] v, String[] s){super(v,s);}\n",t->name);

	fprintf(alias_replica,"\t/**\n");
	fprintf(alias_replica,"\t * @return the interface which this node implements\n");
	fprintf(alias_replica,"\t */\n");
	fprintf(alias_replica,"\tpublic Class<?> getNodeType() {\n");
	fprintf(alias_replica,"\t\treturn jprime.%s.I%s.class;\n",t->name,t->name);
	fprintf(alias_replica,"\t}\n");

	fprintf(alias_replica,"\t/**\n");
	fprintf(alias_replica,"\t * @param used by replicas to do a deep copy of the node.\n");
	fprintf(alias_replica,"\t */\n");
	fprintf(alias_replica,"\tpublic jprime.ModelNode deepCopy(jprime.ModelNode parent) {\n");
	fprintf(alias_replica,"\t\tdoing_deep_copy=true;\n");
	fprintf(alias_replica,"\t\tjprime.%s.%sAliasReplica c = new jprime.%s.%sAliasReplica(this.getName(), (IModelNode)parent,(jprime.%s.%sAlias)this.getReplicatedNode());\n",t->name,t->name,t->name,t->name,t->name,t->name);
	fprintf(alias_replica,"\t\tdoing_deep_copy=false;\n");
	fprintf(alias_replica,"\t\treturn c;\n");
	fprintf(alias_replica,"\t}\n");

	fprintf(alias_replica,"\tpublic static boolean isSubType(IModelNode n) {\n");
	fprintf(alias_replica,"\t\treturn isSubType(n.getTypeId());\n");
	fprintf(alias_replica,"\t}\n");
	fprintf(alias_replica,"\tpublic static boolean isSubType(int id) {\n");
	fprintf(alias_replica,"\t\tswitch(id) {\n");
	//genIsSubType(alias_replica,t,IMPL_ID);
	genIsSubType(alias_replica,t,ALIAS_REPLICA_ID);
	fprintf(alias_replica,"\t\t\t\treturn true;\n");
	fprintf(alias_replica,"\t\t}\n");
	fprintf(alias_replica,"\t\treturn false;\n");
	fprintf(alias_replica,"\t}\n");
	fprintf(alias_replica, "\n\t/* (non-Javadoc)\n");
	fprintf(alias_replica, "\t* @see jprime.IModelNode#getTypeId()\n");
	fprintf(alias_replica, "\t */\n");
	fprintf(alias_replica,"\tpublic abstract int getTypeId();\n");
	genAttrAccessors(alias_replica,t,true,true,false);
	generateChildAccessors(alias_replica,t,true,true,false);
	fprintf(alias_replica, "\n\t/**\n");
	fprintf(alias_replica, "\t * @param kid the child to add\n");
	fprintf(alias_replica, "\t */\n");
#if 0
	fprintf(alias_replica,"\tprotected void addChildToChildLists(IModelNode kid){\n");
	fprintf(alias_replica,"\t\tthrow new RuntimeException(\"Cannot add children to aliases!\");\n");
	fprintf(alias_replica,"\t}\n");
	fprintf(alias_replica,"\tprotected void setupChildLists() {/* there are none! */ }\n");
#endif
	fprintf(alias_replica, "\n\t/**\n");
	fprintf(alias_replica, "\t * @param visitor a generic visitor\n");
	fprintf(alias_replica, "\t */\n");
	fprintf(alias_replica,"\tpublic abstract void accept(jprime.visitors.IGenericVisitor visitor);\n");
	fprintf(alias_replica,"}\n");

	fclose(iface);
	fclose(alias_iface);
	fclose(impl);
	fclose(alias);
	fclose(replica);

	/**
	 * create dir for user modifiable classes
	 */
	sprintf(temp,"%s/%s",jprime_dir,t->name);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}

	/**
	 * interface
	 */
	sprintf(temp,"%s/%s/I%s.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		iface = fopen(temp, "w");
	 	if(iface==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(iface,"\npackage jprime.%s;\n\n",t->name);
		fprintf(iface,"public interface I%s extends jprime.gen.I%s {\n",t->name, t->name);
		fprintf(iface,"//Insert your user-specific code here (if any)\n");
		fprintf(iface,"}\n");
		fclose(iface);
	}

	/**
	 * alias interface
	 */
	sprintf(temp,"%s/%s/I%sAlias.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		alias_iface = fopen(temp, "w");
	 	if(alias_iface==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(alias_iface,"\npackage jprime.%s;\n\n",t->name);
		fprintf(alias_iface,"public interface I%sAlias extends jprime.gen.I%sAlias {\n",t->name, t->name);
		fprintf(alias_iface,"\n\t//Insert your user-specific code here (if any)\n\n");
		fprintf(alias_iface,"}\n");
		fclose(alias_iface);
	}

	sprintf(temp,"%s/%s/%s.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		impl = fopen(temp, "w");
	 	if(impl==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(impl,"\npackage jprime.%s;\n\n",t->name);
		fprintf(impl,"import jprime.variable.*;\n");
		fprintf(impl,"import jprime.ModelNodeRecord;\n");
		fprintf(impl,"import org.python.core.PyObject;\n");

		fprintf(impl,"public class %s extends jprime.gen.%s implements jprime.%s.I%s {\n", t->name, t->name, t->name, t->name);
		fprintf(impl,"\tpublic %s(PyObject[] v, String[] s){super(v,s);}\n",t->name);
		fprintf(impl,"\tpublic %s(ModelNodeRecord rec){ super(rec); }\n",t->name);
		fprintf(impl,"\tpublic %s(jprime.IModelNode parent){ super(parent); }\n",t->name);
		fprintf(impl, "\n\t/* (non-Javadoc)\n");
		fprintf(impl, "\t* @see jprime.IModelNode#getTypeId()\n");
		fprintf(impl, "\t */\n");
		fprintf(impl,"\tpublic int getTypeId(){ return jprime.EntityFactory.%s;}\n",t->name);
		fprintf(impl,"\tpublic void accept(jprime.visitors.IGenericVisitor visitor){visitor.visit(this);}\n");
		fprintf(impl,"\n\t//Insert your user-specific code here (if any)\n\n");
		fprintf(impl,"}\n");
	 	fclose(impl);
	}

 	sprintf(temp,"%s/%s/%sAlias.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		alias = fopen(temp, "w");
	 	if(alias==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(alias,"\npackage jprime.%s;\n\n",t->name);
		fprintf(alias,"import jprime.*;\n");
		fprintf(alias,"import jprime.variable.*;\n");
		fprintf(alias,"import jprime.ModelNodeRecord;\n");
		fprintf(alias,"import org.python.core.PyObject;\n");

		fprintf(alias,"public class %sAlias extends jprime.gen.%sAlias implements jprime.%s.I%sAlias {\n", t->name, t->name, t->name, t->name);
		fprintf(alias,"\tpublic %sAlias(ModelNodeRecord rec){ super(rec); }\n",t->name);
		fprintf(alias,"\tpublic %sAlias(PyObject[] v, String[] s){super(v,s);}\n",t->name);
		fprintf(alias,"\tpublic %sAlias(IModelNode parent){\n\t\tsuper(parent);\n\t}\n",t->name);
		fprintf(alias,"\tpublic %sAlias(IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(alias,"\t\tsuper(parent,(jprime.%s.I%s)referencedNode);\n", t->name, t->name);
		fprintf(alias,"\t}\n");
		fprintf(alias, "\n\t/* (non-Javadoc)\n");
		fprintf(alias, "\t* @see jprime.IModelNode#getTypeId()\n");
		fprintf(alias, "\t */\n");
		fprintf(alias,"\tpublic int getTypeId(){ return jprime.EntityFactory.%sAlias;}\n",t->name);
		fprintf(alias,"\tpublic void accept(jprime.visitors.IGenericVisitor visitor){visitor.visit(this);}\n");
		fprintf(alias,"\n\t//Insert your user-specific code here (if any)\n\n");
		fprintf(alias,"}\n");
	 	fclose(alias);
	}

 	sprintf(temp,"%s/%s/%sReplica.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		replica = fopen(temp, "w");
	 	if(replica==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(replica,"\npackage jprime.%s;\n\n",t->name);
		fprintf(replica,"import jprime.*;\n");
		fprintf(replica,"import jprime.variable.*;\n");
		fprintf(replica,"import jprime.ModelNodeRecord;\n");
		fprintf(replica,"import org.python.core.PyObject;\n");
		fprintf(replica,"public class %sReplica extends jprime.gen.%sReplica implements jprime.%s.I%s {\n", t->name, t->name, t->name, t->name);
		fprintf(replica,"\tpublic %sReplica(ModelNodeRecord rec){ super(rec); }\n",t->name);
		fprintf(replica,"\tpublic %sReplica(PyObject[] v, String[] s){super(v,s);}\n",t->name);
		fprintf(replica,"\tpublic %sReplica(String name, IModelNode parent, jprime.%s.I%s referencedNode) {\n", t->name, t->name, t->name);
		fprintf(replica,"\t\tsuper(name, parent,(jprime.%s.I%s)referencedNode);\n", t->name, t->name);
		fprintf(replica,"\t}\n");
		fprintf(replica, "\n\t/* (non-Javadoc)\n");
		fprintf(replica, "\t* @see jprime.IModelNode#getTypeId()\n");
		fprintf(replica, "\t */\n");
		fprintf(replica,"\tpublic int getTypeId(){ return jprime.EntityFactory.%sReplica;}\n",t->name);
		fprintf(replica,"\tpublic void accept(jprime.visitors.IGenericVisitor visitor){visitor.visit(this);}\n");
		fprintf(replica,"\n\t//Insert your user-specific code here (if any)\n\n");
		fprintf(replica,"}\n");
	 	fclose(replica);
	}

 	sprintf(temp,"%s/%s/%sAliasReplica.java",jprime_dir,t->name,t->name);
	if(!file_exists(temp)) {
		alias_replica = fopen(temp, "w");
	 	if(alias_replica==NULL) {
	 		FATAL("Error opening '%s'\n", temp);
	 	}
		fprintf(alias_replica,"\npackage jprime.%s;\n\n",t->name);
		fprintf(alias_replica,"import jprime.*;\n");
		fprintf(alias_replica,"import jprime.variable.*;\n");
		fprintf(alias_replica,"import jprime.ModelNodeRecord;\n");
		fprintf(alias_replica,"import org.python.core.PyObject;\n");

		fprintf(alias_replica,"public class %sAliasReplica extends jprime.gen.%sAliasReplica implements jprime.%s.I%sAlias {\n", t->name, t->name, t->name, t->name);
		fprintf(alias_replica,"\tpublic %sAliasReplica(ModelNodeRecord rec){ super(rec); }\n",t->name);
		fprintf(alias_replica,"\tpublic %sAliasReplica(PyObject[] v, String[] s){super(v,s);}\n",t->name);
		fprintf(alias_replica,"\tpublic %sAliasReplica(String name, IModelNode parent, jprime.ModelNodeAlias referencedNode) {\n", t->name);
		fprintf(alias_replica,"\t\tsuper(name, parent,referencedNode);\n");
		fprintf(alias_replica,"\t}\n");
		fprintf(alias_replica, "\n\t/* (non-Javadoc)\n");
		fprintf(alias_replica, "\t* @see jprime.IModelNode#getTypeId()\n");
		fprintf(alias_replica, "\t */\n");
		fprintf(alias_replica,"\tpublic int getTypeId(){ return jprime.EntityFactory.%sAliasReplica;}\n",t->name);
		fprintf(alias_replica,"\tpublic void accept(jprime.visitors.IGenericVisitor visitor){visitor.visit(this);}\n");
		fprintf(alias_replica,"\n\t//Insert your user-specific code here (if any)\n\n");
		fprintf(alias_replica,"}\n");
	 	fclose(alias_replica);
	}

	if(BaseEntity) {
		t->extends=BaseEntity;
	}
}

void generateModelNodeVariable(char* jprime_dir) {
	FILE *f;
	char temp[strlen(jprime_dir)+50];
	//temp_ll_t* cur = root;
	sprintf(temp,"%s/gen",jprime_dir);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}
	std::map<uint32_t, std::pair<char*,char*> >::iterator it;

	sprintf(temp,"%s/gen/ModelNodeVariable.java",jprime_dir);
	f = fopen(temp, "w");
 	if(f==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}
 	write_warning(f);
 	fprintf(f,"\npackage jprime.gen;\n\n");
 	fprintf(f,"import java.util.ArrayList;\n");
 	fprintf(f,"import java.util.HashMap;\n");
 	fprintf(f,"import java.util.Map;\n");
 	fprintf(f,"import java.util.Map.Entry;\n");
 	fprintf(f,"import java.util.List;\n");
	fprintf(f,"import java.util.NoSuchElementException;\n\n");
	fprintf(f,"import jprime.variable.BooleanVariable;\n");
	fprintf(f,"import jprime.variable.FloatingPointNumberVariable;\n");
	fprintf(f,"import jprime.variable.ResourceIdentifierVariable;\n");
	fprintf(f,"import jprime.variable.IntegerVariable;\n");
	fprintf(f,"import jprime.variable.OpaqueVariable;\n");
	fprintf(f,"import jprime.variable.StringVariable;\n\n");
#if JPRIME_SEPARATE_PROP_TABLE
	fprintf(f,"public abstract class ModelNodeVariable extends jprime.PersistableObject {\n");
#else
	fprintf(f,"public abstract class ModelNodeVariable {\n");
#endif
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> BOOL = BooleanVariable.class;\n");
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> FLOAT = FloatingPointNumberVariable.class;\n");
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> INT = IntegerVariable.class;\n");
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> OBJECT = OpaqueVariable.class;\n");
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> RESOURCE_ID = ResourceIdentifierVariable.class;\n");
 	fprintf(f,"\tprivate final static Class<? extends ModelNodeVariable> STRING = StringVariable.class;\n");

 	fprintf(f,"\tpublic static class ClsDesc {\n");
 	fprintf(f,"\t\tpublic final String name;\n");
 	fprintf(f,"\t\tpublic final Class<?> cls;\n");
 	fprintf(f,"\t\tpublic final ClsDesc super_desc;\n");
 	fprintf(f,"\t\tpublic final Map<Integer,VarDesc> vars;\n");

 	fprintf(f,"\t\tpublic ClsDesc(String name, Class<?> cls, ClsDesc super_desc) {\n");
 	fprintf(f,"\t\t\tsuper();\n");
 	fprintf(f,"\t\t\tthis.name = name;\n");
 	fprintf(f,"\t\t\tthis.cls = cls;\n");
 	fprintf(f,"\t\t\tthis.super_desc = super_desc;\n");
 	fprintf(f,"\t\t\tthis.vars = new HashMap<Integer,VarDesc>();\n");
	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");

 	fprintf(f,"\tpublic static class VarDesc {\n");
 	fprintf(f,"\t\tpublic final Integer id;\n");
 	fprintf(f,"\t\tpublic final String name;\n");
 	fprintf(f,"\t\tpublic final String doc_string;\n");
 	fprintf(f,"\t\tpublic final String default_value;\n");
 	fprintf(f,"\t\tpublic final boolean is_visualized;\n");
 	fprintf(f,"\t\tpublic final boolean is_stat;\n");
 	fprintf(f,"\t\tpublic final Class<? extends ModelNodeVariable> type;\n");
 	fprintf(f,"\t\tpublic final ClsDesc cls;\n");

 	fprintf(f,"\t\tpublic VarDesc(Integer id, String name, String doc_string, String default_value, boolean is_visualized, boolean is_stat, Class<? extends ModelNodeVariable> type, ClsDesc cls) {\n");
 	fprintf(f,"\t\t\tsuper();\n");
 	fprintf(f,"\t\t\tthis.id = id;\n");
 	fprintf(f,"\t\t\tthis.name = name;\n");
 	fprintf(f,"\t\t\tthis.doc_string = doc_string;\n");
 	fprintf(f,"\t\t\tthis.default_value = default_value;\n");
 	fprintf(f,"\t\t\tthis.is_visualized = is_visualized;\n");
 	fprintf(f,"\t\t\tthis.is_stat = is_stat;\n");
 	fprintf(f,"\t\t\tthis.type = type;\n");
 	fprintf(f,"\t\t\tthis.cls = cls;\n");
 	fprintf(f,"\t\t\tthis.cls.vars.put(this.id,this);\n");
	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");

 	fprintf(f,"\tpublic static class Tripple {\n");
 	fprintf(f,"\t\tpublic final Integer id;\n");
 	fprintf(f,"\t\tpublic final String fname;\n");
 	fprintf(f,"\t\tpublic final Class<?> cls;\n");
 	fprintf(f,"\t\tpublic Tripple(Integer id, String fname, Class<?> cls){\n");
 	fprintf(f,"\t\t\tthis.id=id;\n");
 	fprintf(f,"\t\t\tthis.fname=fname;\n");
 	fprintf(f,"\t\t\tthis.cls=cls;\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");

 	fprintf(f,"\tprotected final static HashMap<String, List<Tripple>> jythonMap = new HashMap<String, List<Tripple>>();\n");
 	fprintf(f,"\tprotected final static HashMap<String, Integer> str2id = new HashMap<String, Integer>();\n");
 	fprintf(f,"\tprotected final static HashMap<Integer, Class<? extends ModelNodeVariable>> varTypes = new HashMap<Integer, Class<? extends ModelNodeVariable>>();\n");
 	fprintf(f,"\tprotected final static HashMap<Class<?>,ClsDesc> clsDescs = new HashMap<Class<?>,ClsDesc>();\n");

 	for(it=var_ids.begin();it!=var_ids.end();it++) {
 	 	fprintf(f,"\n\tprivate final static String _%s=new String(\"%s\");\n", (*it).second.first, (*it).second.first);
 		fprintf(f,"\tpublic static int %s(){return %u;}\n", (*it).second.first, (*it).first);
 	}

 	fprintf(f,"\tstatic {\n");
	fprintf(f,"\n\n\t\t//*************************\n");
	fprintf(f,"\t\t//generate jython map valus for attribute accessors\n");
	fprintf(f,"\t\t//*************************\n\n");
 	for(it=var_ids.begin();it!=var_ids.end();it++) {
 		fprintf(f,"\n\t\t//*************************\n");
 	 	fprintf(f,"\t\tstr2id.put(_%s, %s());\n", (*it).second.first, (*it).second.first);
 	 	fprintf(f,"\t\tvarTypes.put(%s(), %s);\n", (*it).second.first, (*it).second.second);

 	 	fprintf(f,"\n\t\tif(!jythonMap.containsKey(_%s))jythonMap.put(_%s, new ArrayList<Tripple>());\n", (*it).second.first, (*it).second.first);
 	 	fprintf(f,"\t\tjythonMap.get(_%s).add(new Tripple(%s(),\"set%s\",String.class));\n", (*it).second.first, (*it).second.first,fixAttrName((*it).second.first).c_str());
 	}

	temp_ll_t* cur = root;
	uint32_t status=0;
	const char  *types[] = {"","Alias","Replica"};
	fprintf(f,"\n\n\t\t//*************************\n");
	fprintf(f,"\t\t//generate jython map valus for child accessors\n");
	fprintf(f,"\t\t//*************************\n\n");
	while(cur) {
		if(cur->data && strcmp(cur->data->name,"BaseEntity")) {
			config_child_t* ct=cur->data->first_child;
			while(ct) {
				if(!ct->the_type) {
					FATAL("should never see this\n");
				}

		 		fprintf(f,"\n\t\t//*************************\n");
		 	 	fprintf(f,"\t\tif(!jythonMap.containsKey(\"%s\"))jythonMap.put(\"%s\",new ArrayList<Tripple>());\n",ct->name,ct->name);
				if(ct->is_aliased) {
					//special case for link attachments
					if(strcmp("attachments",ct->name)==0) {
						fprintf(f,"\t\tjythonMap.get(\"%s\").add(new Tripple(-1,\"add%s\",jprime.%s.I%s.class));\n",
								ct->name, ct->the_type->name,
								ct->the_type->name,ct->the_type->name);
					}
					fprintf(f,"\t\tjythonMap.get(\"%s\").add(new Tripple(-1,\"add%sAlias\",jprime.%s.I%sAlias.class));\n",
							ct->name, ct->the_type->name,
							ct->the_type->name,ct->the_type->name);
				}
				else {
			 	 	for(int i =0;i<3;i++) {
			 	 		fprintf(f,"\t\tjythonMap.get(\"%s\").add(new Tripple(-1,\"add%s%s\",jprime.%s.%s%s.class));\n",
			 	 				ct->name, ct->the_type->name,types[i],
			 	 				ct->the_type->name,ct->the_type->name,types[i]);
			 	 	}
				}
				ct=ct->next;
			}
		}
		cur=cur->next;
	}

	fprintf(f,"\n\n\t\t//*************************\n");
	fprintf(f,"\t\t//generate default values\n");
	fprintf(f,"\t\t//*************************\n\n");
	//printf("START generating default values!\n");
	std::list<config_type_t*> root_types;
	root_types.push_back(root_type->data);
	while(root_types.size()>0) {
		config_type_t* cur_type=root_types.front();
		root_types.pop_front();
		fprintf(f,"\n\t\t//*************************\n");
		fprintf(f,"\t\t//for type %s[%s]\n",cur_type->name,(cur_type->extends)?(cur_type->extends):"NUL");
		fprintf(f,"\t\t//*************************\n");
		fprintf(f,"\t\t{\n");
		//printf("\ton type %s[%s]\n",cur_type->name,(cur_type->extends)?(cur_type->extends):"NUL");fflush(stdout);

		config_var_t* var=cur_type->first_var;
		char kls[1000];
		bool first=true;
		while(var) {
		//while(var && cur_type != root_type->data) {
			if(var->is_configurable) {
				if(cur_type==root_type->data) {
					sprintf(kls,"null");
				}
				else if(cur_type->extends==NULL || strcmp("BaseEntity",cur_type->extends)==0){
					sprintf(kls,"jprime.ModelNode.class");
				}
				else if(strcmp("Alias",cur_type->extends)==0){
					sprintf(kls,"jprime.ModelNodeAlias.class");
				}
				else {
					sprintf(kls,"jprime.%s.%s.class",cur_type->extends,cur_type->extends);
				}
				//printf("\t\tdefautls for var %s[%s]\n",var->name,kls);fflush(stdout);
				if(first) {
					if(cur_type==root_type->data){
						fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"ModelNode\", jprime.ModelNode.class, null);\n");
					}
					else if(cur_type->extends==NULL || strcmp("BaseEntity",cur_type->extends)==0){
						fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.ModelNode.class, clsDescs.get(%s));\n",cur_type->name,kls);
					}
					else if(strcmp("Alias",cur_type->extends)==0){
						fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.ModelNodeAlias.class, clsDescs.get(%s));\n",cur_type->name,kls);
					}
					else {
						fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.%s.%s.class, clsDescs.get(%s));\n",cur_type->name,cur_type->name,cur_type->name,kls);
					}
					if(cur_type!=root_type->data){
						fprintf(f,"\t\t\tfor(Entry<Integer, VarDesc> e : cls.super_desc.vars.entrySet()) {\n");
						fprintf(f,"\t\t\t\tcls.vars.put(e.getKey(), e.getValue());\n");
						fprintf(f,"\t\t\t}\n");
					}
					first=false;
				}
				fprintf(f,"\t\t\tnew VarDesc(%s(), \"%s\", \"%s\", \"%s\", %s, %s, varTypes.get(%s()), cls);\n",
						var->name,
						var->name,
						var->doc_string,
						var->default_value,
						(var->is_visualized?"true":"false"),
						(var->is_stat==1?"true":"false"),
						var->name);
			}
			var=var->next;
		}
		if(cur_type==root_type->data) {
			//fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"ModelNode\", jprime.ModelNode.class, null);\n");
			fprintf(f,"\t\t\tclsDescs.put(jprime.ModelNode.class, cls);\n\n");
		}
		else if(!strcmp("Alias",cur_type->name)){
			fprintf(f,"\t\t\tclsDescs.put(jprime.ModelNodeAlias.class, cls);\n\n");
		}
		else {
			if(first) {
				if(cur_type==root_type->data) {
					sprintf(kls,"null");
				}
				else if(cur_type->extends==NULL || strcmp("BaseEntity",cur_type->extends)==0){
					sprintf(kls,"jprime.ModelNode.class");
				}
				else if(strcmp("Alias",cur_type->extends)==0){
					sprintf(kls,"jprime.ModelNodeAlias.class");
				}
				else {
					sprintf(kls,"jprime.%s.%s.class",cur_type->extends,cur_type->extends);
				}
				if(cur_type->extends==NULL || strcmp("BaseEntity",cur_type->extends)==0){
					fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.ModelNode.class, clsDescs.get(%s));\n",cur_type->name,kls);
				}
				else if(strcmp("Alias",cur_type->extends)==0){
					fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.ModelNodeAlias.class, clsDescs.get(%s));\n",cur_type->name,kls);
				}
				else {
					fprintf(f,"\t\t\tClsDesc cls = new ClsDesc(\"%s\", jprime.%s.%s.class, clsDescs.get(%s));\n",cur_type->name,cur_type->name,cur_type->name,kls);
				}
				fprintf(f,"\t\t\tfor(Entry<Integer, VarDesc> e : cls.super_desc.vars.entrySet()) {\n");
				fprintf(f,"\t\t\t\tcls.vars.put(e.getKey(), e.getValue());\n");
				fprintf(f,"\t\t\t}\n");
				first=false;
			}
			sprintf(kls,"jprime.%s.%s",cur_type->name,cur_type->name);
			fprintf(f,"\t\t\tclsDescs.put(%s.class, cls);\n",kls);
			fprintf(f,"\t\t\tclsDescs.put(%sReplica.class, cls);\n",kls);
		}

		fprintf(f,"\t\t}\n");
		cur_type=cur_type->first_sub_type;
		while(cur_type) {
			root_types.push_back(cur_type);
			cur_type=cur_type->next;
		}

	}

	//generate types for the aliases...
	fprintf(f,"\n\n\t\t//*************************\n");
	fprintf(f,"\t\t//add entries for aliases\n");
	fprintf(f,"\t\t//*************************\n");
	root_types.push_back(root_type->data);
	while(root_types.size()>0) {
		config_type_t* cur_type=root_types.front();
		root_types.pop_front();

		if(cur_type!=root_type->data && strcmp("Alias",cur_type->name)){
			fprintf(f,"\t\t\tclsDescs.put(jprime.%s.%sAlias.class, clsDescs.get(jprime.ModelNodeAlias.class));\n",cur_type->name,cur_type->name);
			fprintf(f,"\t\t\tclsDescs.put(jprime.%s.%sAliasReplica.class, clsDescs.get(jprime.ModelNodeAlias.class));\n",cur_type->name,cur_type->name);
		}


		cur_type=cur_type->first_sub_type;
		while(cur_type) {
			root_types.push_back(cur_type);
			cur_type=cur_type->next;
		}
	}

	fprintf(f,"\t}\n\n\n");


	fprintf(f,"\tpublic static ClsDesc getClsDesc(jprime.ModelNode m) {\n");
	fprintf(f,"\t\treturn clsDescs.get(m.getClass());\n");
	fprintf(f,"\t}\n");

	fprintf(f,"\tpublic static List<Tripple> jythonName2Tripples(String name) {\n");
	fprintf(f,"\t\tif(jythonMap.containsKey(name))\n");
	fprintf(f,"\t\t\treturn jythonMap.get(name);\n");
	fprintf(f,"\t\treturn null;\n");
	fprintf(f,"\t}\n");

	fprintf(f,"\tpublic static int name2int(String name){\n");
	fprintf(f,"\t\tInteger id = null;\n");
	fprintf(f,"\t\tid = str2id.get(name);\n");
	fprintf(f,"\t\tif(id==null)\n");
	fprintf(f,"\t\t\tthrow new NoSuchElementException(\"The name \\\"\"+name+\"\\\" was not found in the str2id map\");\n");
	fprintf(f,"\t\treturn id;\n");
	fprintf(f,"\t}\n");

	fprintf(f,"\tpublic static Class<? extends ModelNodeVariable > int2type(Integer attr_id){\n");
	fprintf(f,"\t\tClass<? extends ModelNodeVariable > type = null;\n");
	fprintf(f,"\t\ttype = varTypes.get(attr_id);\n");
	fprintf(f,"\t\tif(type==null)\n");
	fprintf(f,"\t\t\tthrow new NoSuchElementException(\"The attr_id \\\"\"+attr_id+\"\\\" was not found in the varTypes map\");\n");
	fprintf(f,"\t\treturn type;\n");
	fprintf(f,"\t}\n");


	fprintf(f,"\tpublic static String int2name(int id){\n");
	fprintf(f,"\t\tswitch(id) {\n");
 	for(it=var_ids.begin();it!=var_ids.end();it++) {
 		fprintf(f,"\t\t\tcase %u: return _%s;\n", (*it).first, (*it).second.first);
 	}
	fprintf(f,"\t\t}\n");
	fprintf(f,"\t\tthrow new NoSuchElementException(\"The id \\\"\"+id+\"\\\" was not found in the id2str map\");\n");
	fprintf(f,"\t}\n");
	fprintf(f,"}\n");

	fclose(f);
}

void generateEntityFactory(char* jprime_dir) {
	FILE *f;
	std::map<std::string, config_type_t*>::iterator it;
	char temp[strlen(jprime_dir)+50];
	sprintf(temp,"%s/gen",jprime_dir);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}
	sprintf(temp,"%s/gen/EntityFactory.java",jprime_dir);
	f = fopen(temp, "w");
 	if(f==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}
 	write_warning(f);
 	fprintf(f,"\npackage jprime.gen;\n\n");
 	fprintf(f,"public class EntityFactory {\n");

 	std::map<int,std::string> fourtypes;
 	fourtypes[IMPL_ID]="";
 	fourtypes[ALIAS_ID]="Alias";
 	fourtypes[REPLICA_ID]="Replica";
 	fourtypes[ALIAS_REPLICA_ID]="AliasReplica";

 	std::map<int,std::string>::iterator tit;
 	int max=0;
	for(it=types.begin();it!=types.end();it++) {
 		fprintf(f,"\n\t//******** %s\n", (*it).second->name);
 	 	for ( tit=fourtypes.begin() ; tit != fourtypes.end(); tit++ ) {
 	 		fprintf(f,"\tpublic static final int %s%s = %i;\n", (*it).second->name, (*tit).second.c_str(), (*it).second->auto_type_ids[(*tit).first]);
 	 		if((*it).second->auto_type_ids[(*tit).first]>max)
 	 			max=(*it).second->auto_type_ids[(*tit).first];
 	 	}
 	}
	max++;
	fprintf(f,"\tpublic static final int MAX_TYPE_ID = %i;\n",max);
	fprintf(f,"\n\n\n");


 	fprintf(f,"\tpublic static String getString(int type_id){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
 	 	for ( tit=fourtypes.begin() ; tit != fourtypes.end(); tit++ ) {
 	 		fprintf(f,"\t\t\tcase %i: return new String(\"%s%s\");\n",
 	 				(*it).second->auto_type_ids[(*tit).first],
 	 				(*it).second->name,
 	 				(*tit).second.c_str());
 	 	}
	}
 	fprintf(f,"\t\t\tdefault: return null;\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");


 	fprintf(f,"\tpublic static jprime.ModelNode createNode(int type_id, jprime.ModelNodeRecord rec){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
		if(strcmp((*it).second->name,"BaseEntity")==0 || strcmp((*it).second->name,"Alias")==0) continue;
 	 	for ( tit=fourtypes.begin() ; tit != fourtypes.end(); tit++ ) {
 	 		fprintf(f,"\t\t\tcase %i: return new jprime.%s.%s%s(rec);\n",
 	 				(*it).second->auto_type_ids[(*tit).first],
 	 				(*it).second->name,
 	 				(*it).second->name,
 	 				(*tit).second.c_str());
 	 	}
	}
 	fprintf(f,"\t\t\tdefault: throw new RuntimeException(\"Unkonwn type \"+type_id+\"!\");\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static jprime.ModelNode createNode(int type_id, jprime.ModelNode parent){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
		if(strcmp((*it).second->name,"BaseEntity")==0 || strcmp((*it).second->name,"Alias")==0) continue;
		fprintf(f,"\t\t\tcase %i: return new jprime.%s.%s(parent);\n",
				(*it).second->auto_type_ids[IMPL_ID],
				(*it).second->name,
				(*it).second->name);
	}
 	fprintf(f,"\t\t\tdefault: throw new RuntimeException(\"Unkonwn type \"+type_id+\"!\");\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static jprime.ModelNode createNodeReplica(int type_id, String name, jprime.IModelNode parent, jprime.ModelNode toRep){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
		if(strcmp((*it).second->name,"BaseEntity")==0 || strcmp((*it).second->name,"Alias")==0) continue;
		fprintf(f,"\t\t\tcase %i: return new jprime.%s.%sReplica(name, parent, (jprime.%s.%s)toRep);\n",
				(*it).second->auto_type_ids[REPLICA_ID],
				(*it).second->name,
				(*it).second->name,
				(*it).second->name,
				(*it).second->name);
	}
 	fprintf(f,"\t\t\tdefault: throw new RuntimeException(\"Unkonwn type \"+type_id+\"!\");\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static jprime.ModelNode createNodeAlias(int type_id, jprime.ModelNode parent, jprime.ModelNode toAlias){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
		if(strcmp((*it).second->name,"BaseEntity")==0 || strcmp((*it).second->name,"Alias")==0) continue;
		fprintf(f,"\t\t\tcase %i: return new jprime.%s.%sAlias(parent, (jprime.%s.%s)toAlias);\n",
				(*it).second->auto_type_ids[ALIAS_ID],
				(*it).second->name,
				(*it).second->name,
				(*it).second->name,
				(*it).second->name);
	}
 	fprintf(f,"\t\t\tdefault: throw new RuntimeException(\"Unkonwn type \"+type_id+\"!\");\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static jprime.ModelNode createNodeAliasReplica(int type_id, String name, jprime.ModelNode parent, jprime.ModelNode toRep){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
		if(strcmp((*it).second->name,"BaseEntity")==0 || strcmp((*it).second->name,"Alias")==0) continue;
		fprintf(f,"\t\t\tcase %i: return new jprime.%s.%sAliasReplica(name, parent, (jprime.%s.%sAlias)toRep);\n",
				(*it).second->auto_type_ids[ALIAS_REPLICA_ID],
				(*it).second->name,
				(*it).second->name,
				(*it).second->name,
				(*it).second->name);
	}
 	fprintf(f,"\t\t\tdefault: throw new RuntimeException(\"Unkonwn type \"+type_id+\"!\");\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static boolean isModelNode(jprime.IModelNode n){ return isModelNode(n.getTypeId()); }\n");
 	fprintf(f,"\tpublic static boolean isModelNode(int type_id){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
	 	fprintf(f,"\t\t\tcase %i:\n", (*it).second->auto_type_ids[IMPL_ID]);
	}
 	fprintf(f,"\t\t\t\treturn true;\n");
 	fprintf(f,"\t\t\tdefault: return false;\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static boolean isAlias(jprime.IModelNode n){ return isAlias(n.getTypeId()); }\n");
 	fprintf(f,"\tpublic static boolean isAlias(int type_id){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
	 	fprintf(f,"\t\t\tcase %i:\n", (*it).second->auto_type_ids[ALIAS_ID]);
	 	fprintf(f,"\t\t\tcase %i:\n", (*it).second->auto_type_ids[ALIAS_REPLICA_ID]);
	}
 	fprintf(f,"\t\t\t\treturn true;\n");
 	fprintf(f,"\t\t\tdefault: return false;\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static boolean isReplica(jprime.IModelNode n){ return isReplica(n.getTypeId()); }\n");
 	fprintf(f,"\tpublic static boolean isReplica(int type_id){\n");
 	fprintf(f,"\t\tswitch(type_id){\n");
	for(it=types.begin();it!=types.end();it++) {
	 	fprintf(f,"\t\t\tcase %i:\n", (*it).second->auto_type_ids[REPLICA_ID]);
	 	fprintf(f,"\t\t\tcase %i:\n", (*it).second->auto_type_ids[ALIAS_REPLICA_ID]);
	}
 	fprintf(f,"\t\t\t\treturn true;\n");
 	fprintf(f,"\t\t\tdefault: return false;\n");
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\t}\n");
 	fprintf(f,"\n\n\n");

 	fprintf(f,"\tpublic static boolean isSubType(int super_type_id, int sub_type_id){\n");
 	temp_ll_t* cur=root;
 	fprintf(f,"\t\tswitch(super_type_id) {\n");
	while(cur) {
		if(cur->data && strcmp("BaseEntity",cur->data->name))  {
			if(strcmp(cur->data->name,"Alias")) {
				//we dont want to generate code for aliases!
				fprintf(f,"\t\t\tcase %i: return jprime.gen.%s.isSubType(sub_type_id);\n",cur->data->auto_type_ids[IMPL_ID],cur->data->name);
				fprintf(f,"\t\t\tcase %i: return jprime.gen.%sAlias.isSubType(sub_type_id);\n",cur->data->auto_type_ids[ALIAS_ID],cur->data->name);
				fprintf(f,"\t\t\tcase %i: return jprime.gen.%sReplica.isSubType(sub_type_id);\n",cur->data->auto_type_ids[REPLICA_ID],cur->data->name);
				fprintf(f,"\t\t\tcase %i: return jprime.gen.%sAliasReplica.isSubType(sub_type_id);\n",cur->data->auto_type_ids[ALIAS_REPLICA_ID],cur->data->name);
			}
		}
		cur=cur->next;
	}
 	fprintf(f,"\t\t}\n");
 	fprintf(f,"\tthrow new RuntimeException(\"Unknown type id '\"+super_type_id+\"'.\");\n");
 	fprintf(f,"\t}\n");


 	fprintf(f,"}\n");
	fclose(f);
}


void generateGenericVisitor(char* jprime_dir) {
	FILE *f;
	std::map<std::string, config_type_t*>::iterator it;
	char temp[strlen(jprime_dir)+50];
	sprintf(temp,"%s/gen",jprime_dir);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}
	sprintf(temp,"%s/gen/IGenericVisitor.java",jprime_dir);
	f = fopen(temp, "w");
 	if(f==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}
 	write_warning(f);
 	fprintf(f,"\npackage jprime.gen;\n\n");
 	fprintf(f,"public interface IGenericVisitor {\n");
 	temp_ll_t* cur=root;
	while(cur) {
		if(cur->data && strcmp(cur->data->name,"BaseEntity"))  {
			if(strcmp(cur->data->name,"Alias")) {
				//we dont want to generate code for aliases!
				fprintf(f,"\tvoid visit(jprime.%s.%s node);\n",cur->data->name,cur->data->name);
				fprintf(f,"\tvoid visit(jprime.%s.%sAlias node);\n",cur->data->name,cur->data->name);
				fprintf(f,"\tvoid visit(jprime.%s.%sReplica node);\n",cur->data->name,cur->data->name);
				fprintf(f,"\tvoid visit(jprime.%s.%sAliasReplica node);\n",cur->data->name,cur->data->name);
			}
		}
		cur=cur->next;
	}
 	fprintf(f,"}\n");
 	fclose(f);
}

void generateTLV(char* jprime_dir) {
	FILE *f;
	char temp[strlen(jprime_dir)+50];
	sprintf(temp,"%s/gen",jprime_dir);
	if(!dir_exists(temp)) {
		mkdir(temp,0777);
	}
	sprintf(temp,"%s/gen/TLV.java",jprime_dir);
	f = fopen(temp, "w");
 	if(f==NULL) {
 		FATAL("Error opening '%s'\n", temp);
 	}
 	write_warning(f);
 	fprintf(f,"\npackage jprime.gen;\n\n");
 	fprintf(f,"public class TLV {\n");
	fprintf(f, "\tpublic static final int PROPERTY = %i;\n", _JPRIME_PROPERTY);
	fprintf(f, "\tpublic static final int SYMBOL_TABLE = %i;\n", _JPRIME_SYMBOL_TABLE);
	fprintf(f, "\tpublic static final int PARTITION = %i;\n", _JPRIME_PARTITION);
	fprintf(f, "\tpublic static final int COMMUNITY = %i;\n", _JPRIME_COMMUNITY);
	fprintf(f, "\tpublic static final int SYMBOL_TABLE_ENTRY = %i;\n", _JPRIME_SYMBOL_TABLE_ENTRY);
	fprintf(f, "\tpublic static final int ROUTE_TABLE = %i;\n", _JPRIME_ROUTE_TABLE);
	fprintf(f, "\tpublic static final int ROUTE_ENTRY = %i;\n", _JPRIME_ROUTE_ENTRY);
	fprintf(f, "\tpublic static final int GHOST_NODE = %i;\n", _JPRIME_GHOST_NODE);
	fprintf(f, "\tpublic static final int GENERIC_NODE = %i;\n", _JPRIME_GENERIC_NODE);
	fprintf(f,"}\n");
 	fclose(f);
}

void generateJavaCode(char* jprime_dir) {
	temp_ll_t* cur = root;
	uint32_t status=0;
	while(cur) {
		if(cur->data && strcmp(cur->data->name,"BaseEntity")) {
			generateJavaType(jprime_dir, cur->data);
		}
		cur=cur->next;
	}
	generateGenericVisitor(jprime_dir);
	generateEntityFactory(jprime_dir);
	generateModelNodeVariable(jprime_dir);
	generateTLV(jprime_dir);
}

int __main__(int argc, char** argv)
{
	if(argc !=5) {
		fprintf(stderr,"Usage: %s <path to master_state_config.m> <path to configurable_types.h> <path to configurable_types.cc> <path to jprime>\n", argv[0]);
		return 100;
	}
	if(lex_setup(argv[1])) return 0;
	yyparse();
	lex_teardown();
	fix_type_heirarchy();
	//std::cout <<"generateVariableIds"<<std::endl;
	generateVariableIds();
	//std::cout <<"generateJavaCode("<<argv[4]<<")"<<std::endl;
	generateJavaCode(argv[4]);

	char** model_var_names = new char*[8];
	int* model_var_ids = new int[8];
	model_var_names[0]=strdup("BooleanVariable");
	model_var_names[1]=strdup("FloatingPointNumberVariable");
	model_var_names[2]=strdup("IntegerVariable");
	model_var_names[3]=strdup("ListVariable");
	model_var_names[4]=strdup("OpaqueVariable");
	model_var_names[5]=strdup("ResourceIdentifierVariable");
	model_var_names[6]=strdup("StringVariable");
	model_var_names[7]=strdup("SymbolVariable");

	model_var_ids[0]=100;
	model_var_ids[1]=101;
	model_var_ids[2]=102;
	model_var_ids[3]=103;
	model_var_ids[4]=104;
	model_var_ids[5]=105;
	model_var_ids[6]=106;
	model_var_ids[7]=107;
	generateCPPCode(argv[2], argv[3],model_var_names,model_var_ids,8);
	return 0;
}



